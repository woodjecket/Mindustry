From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: way-zer <himc.wicp@gmail.com>
Date: Thu, 25 Apr 2024 14:49:41 +0800
Subject: [PATCH] =?UTF-8?q?OC:=20=E4=BC=98=E5=8C=96Batch=E6=80=A7=E8=83=BD?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

大幅优化渲染性能
UPDATE1: 增加配置项，默认关闭
UPDATE2: 优化性能；我真的已经尽力了，剩下的只能怪java慢了
UPDATE3: 完全重写了sort，又提升了一倍sort性能
UPDATE4: 修复一些bug，并优化性能。这次重写了IntIntMap。(排序算法相当于完全重写完了)
UPDATE5: 修复文字渲染错误

sorted不写回，减少开销。
way-zer <himc.wicp@gmail.com> on 2024/5/28
---
 .../plugins/mindustryX/patchArc.gradle.kts    |   5 +
 core/assets/bundles/bundle-mdtx.properties    |   4 +-
 .../arc/graphics/g2d/MySortedSpriteBatch.java | 257 +++++++++
 .../arc/graphics/g2d/SortedSpriteBatch2.java  | 545 ++++++++++++++++++
 core/src/mindustry/ClientLauncher.java        |  11 +-
 core/src/mindustryX/features/RenderExt.java   |   2 +
 core/src/mindustryX/features/Settings.java    |   3 +
 7 files changed, 816 insertions(+), 11 deletions(-)
 create mode 100644 core/src/arc/graphics/g2d/MySortedSpriteBatch.java
 create mode 100644 core/src/arc/graphics/g2d/SortedSpriteBatch2.java

diff --git a/buildPlugins/plugins/mindustryX/patchArc.gradle.kts b/buildPlugins/plugins/mindustryX/patchArc.gradle.kts
index 4715953ea1db8e20fe922911ba8054b8a8231fea..3810100480eb0ab0475ed8538be46e00fc15d742 100644
--- a/buildPlugins/plugins/mindustryX/patchArc.gradle.kts
+++ b/buildPlugins/plugins/mindustryX/patchArc.gradle.kts
@@ -2,6 +2,7 @@ package mindustryX
 
 import javassist.ClassPool
 import javassist.CtClass
+import javassist.Modifier
 import javassist.bytecode.Bytecode
 import javassist.bytecode.Descriptor
 import java.util.zip.ZipFile
@@ -28,6 +29,10 @@ abstract class PatchArc : TransformAction<TransformParameters.None> {
                 methodInfo.codeAttribute.iterator().insertEx(code.get())
                 methodInfo.rebuildStackMapIf6(classPool, classFile)
             }
+        },
+        "arc.graphics.g2d.DrawRequest" to clz@{
+            modifiers = modifiers or Modifier.PUBLIC
+//            addField(CtField.make("public int zOffset;", this@clz))
         }
     )
 
diff --git a/core/assets/bundles/bundle-mdtx.properties b/core/assets/bundles/bundle-mdtx.properties
index 353ba491c42b48dbda2a990730f8a82a9dc4984d..73d44853f9615430d7d462591f0ccbe5d381e3e5 100644
--- a/core/assets/bundles/bundle-mdtx.properties
+++ b/core/assets/bundles/bundle-mdtx.properties
@@ -66,6 +66,9 @@ setting.blockRenderLevel.name = [cyan]建筑渲染等级
 category.entitySettings.name = 实体相关设置
 setting.bulletShow.name = 显示子弹
 setting.showminebeam.name = 显示单位挖掘光束
+
+category.developerMode.name = 特殊设置
+setting.renderSort.name = 渲染排序 [grey]实验性功能，能够提升50%渲染性能，但可能造成渲染错误
 #end Settings
 
 bar.reloadDetail = 装填：{0}%
@@ -169,7 +172,6 @@ category.arcShareinfo.name = 多人游玩设置
 category.arcStrongCheat.name = [red]强作弊功能
 category.arcWeakCheat.name = 弱作弊功能
 category.combat = 战斗
-category.developerMode.name = 特殊设置
 category.moreContent.name = 更多内容适配
 category.movement = 移动
 category.personalized.name = 自定义客户端     [需要重启]
diff --git a/core/src/arc/graphics/g2d/MySortedSpriteBatch.java b/core/src/arc/graphics/g2d/MySortedSpriteBatch.java
new file mode 100644
index 0000000000000000000000000000000000000000..1f0460890b8c7665b5be86bf18cd2787d6021e94
--- /dev/null
+++ b/core/src/arc/graphics/g2d/MySortedSpriteBatch.java
@@ -0,0 +1,257 @@
+package arc.graphics.g2d;
+
+import arc.graphics.*;
+import arc.math.*;
+import mindustryX.features.*;
+
+import java.util.*;
+
+public class MySortedSpriteBatch extends SortedSpriteBatch2{
+    private static final boolean DEBUG = false;
+    private static final int PRIME1 = 0xbe1f14b1;
+    private static final int PRIME2 = 0xb4b82e39;
+    int[] extraZ = new int[10000];
+    //增加小的delta，来保持原来的前后顺序
+    int orderZ = 0;
+    int hashZ = 0;//打乱hash值，来检查渲染异常
+
+    @Override
+    protected void z(float z){
+        if(this.z == z) return;
+        orderZ = 0;
+        super.z(z);
+    }
+
+    @Override
+    protected void flushRequests(){
+        if(!flushing){
+            DebugUtil.lastDrawRequests += numRequests;
+            super.flushRequests();
+        }
+    }
+
+    @Override
+    protected void expandRequests(){
+        super.expandRequests();
+        extraZ = new int[requests.length];
+    }
+
+    @Override
+    protected void draw(TextureRegion region, float x, float y, float originX, float originY, float width, float height, float rotation){
+        super.draw(region, x, y, originX, originY, width, height, rotation);
+        if(sort && !flushing && RenderExt.renderSort){
+            int h = region.texture.hashCode();
+            if(DEBUG){
+                h = (h + hashZ) * PRIME1;
+                h = h ^ (h >>> 16);
+            }
+            extraZ[numRequests - 1] = ((orderZ++) << 16) | (h & 0xffff);
+        }
+    }
+
+    @Override
+    protected void draw(Texture texture, float[] spriteVertices, int offset, int count){
+        super.draw(texture, spriteVertices, offset, count);
+        if(sort && !flushing && RenderExt.renderSort){
+            int h = texture.hashCode();
+            if(DEBUG){
+                h = (h + hashZ) * PRIME1;
+                h = h ^ (h >>> 16);
+            }
+            int[] extraZ = this.extraZ;
+            int v = ((orderZ++) << 16) | (h & 0xffff);
+            for(int i = (count - offset) / SPRITE_SIZE; i > 0; i--){
+                extraZ[numRequests - i] = v;
+            }
+        }
+    }
+
+    @Override
+    protected void draw(Runnable request){
+        super.draw(request);
+        if(sort && !flushing && RenderExt.renderSort){
+            int h = DEBUG ? hashZ : 0;
+            extraZ[numRequests - 1] = ((orderZ++) << 16) | (h & 0xffff);
+        }
+    }
+
+    @Override
+    protected void sortRequests(){
+        if(!RenderExt.renderSort){
+            super.sortRequests();
+            return;
+        }
+        hashZ = DEBUG ? Float.floatToIntBits((float)Math.random()) : 0;
+
+        int numRequests = this.numRequests;
+        int[] arr = this.requestZ, extraZ = this.extraZ;
+        sortMap(arr, numRequests);
+        sortMap(extraZ, numRequests);
+        for(int i = 0; i < numRequests; i++){
+            arr[i] = (arr[i] << 16) | extraZ[i];
+        }
+        countingSortMap(arr, numRequests);//arr is loc now;
+
+        if(copy.length < requests.length) copy = new DrawRequest[requests.length];
+        final DrawRequest[] items = requests, dest = copy;
+        for(int i = 0; i < numRequests; i++){
+            dest[arr[i]] = items[i];
+        }
+    }
+
+    private static final IntIntMap vMap = new IntIntMap(10000, 0.25f);
+    private static int[] order = new int[1000];
+    private static int[] order2 = new int[1000];
+
+    /** 将输入arr映射到有序的0-n域 */
+    private static int sortMap(int[] arr, int len){
+        var map = MySortedSpriteBatch.vMap;
+        int[] order = MySortedSpriteBatch.order;
+        map.clear();
+        int unique = 0;
+        for(int i = 0; i < len; i++){
+            int v = arr[i];
+            int id = map.getOrPut(v, unique);
+            arr[i] = id;//arr现在表示id
+            if(id == unique){
+                if(order.length <= unique){
+                    order = Arrays.copyOf(order, unique << 1);
+                }
+                order[unique] = v;
+                unique++;
+            }
+        }
+        MySortedSpriteBatch.order = order;
+
+        //对z值排序
+        Arrays.sort(order, 0, unique);//order -> z
+
+        //arr中储存order
+        int[] order2 = MySortedSpriteBatch.order2;//id -> order
+        if(order2.length < order.length){
+            order2 = new int[order.length];
+            MySortedSpriteBatch.order2 = order2;
+        }
+        for(int i = 0; i < unique; i++){
+            order2[map.getOrPut(order[i], -1)] = i;
+        }
+        for(int i = 0; i < len; i++){
+            arr[i] = order2[arr[i]];
+        }
+        return unique;
+    }
+
+    private static void countingSortMap(int[] arr, int len){
+        int[] order = MySortedSpriteBatch.order, counts = MySortedSpriteBatch.order2;
+        var map = MySortedSpriteBatch.vMap;
+        map.clear();
+        int unique = 0;
+        for(int i = 0; i < len; i++){
+            int v = arr[i];
+            int id = map.getOrPut(v, unique);
+            arr[i] = id;//arr现在表示id
+            if(id == unique){
+                if(unique >= counts.length){
+                    order = Arrays.copyOf(order, unique << 1);
+                    counts = Arrays.copyOf(counts, unique << 1);
+                    MySortedSpriteBatch.order = order;
+                    MySortedSpriteBatch.order2 = counts;
+                }
+                order[unique] = v;
+                counts[unique] = 1;
+                unique++;
+            }else counts[id]++;
+        }
+
+        //对z值排序
+        Arrays.sort(order, 0, unique);//order -> z
+
+        //将counts转换为locs
+        int loc = 0;
+        for(int i = 0; i < unique; i++){
+            int id = map.getOrPut(order[i], -1);
+            int c = counts[id];
+            counts[id] = loc;
+            loc += c;
+        }
+        //arr现在表示新目的地
+        for(int i = 0; i < len; i++){
+            arr[i] = counts[arr[i]]++;
+        }
+    }
+
+    static public class IntIntMap{
+        private int[] keys;
+        private boolean hasZero;
+        private int[] values;
+        private int zeroValue;
+        private int size; // 哈希表中的元素数量
+
+        private int capacity, maxSize;
+        private float loadFactor;
+        private int mask, hashShift;
+
+        public IntIntMap(int capacity, float loadFactor){
+            setCapacity(capacity, loadFactor);
+        }
+
+        private int hash(int key){
+            key *= PRIME2;
+            return (key ^ key >>> hashShift);
+        }
+
+        public int getOrPut(int key, int defaultValue){
+            if(key == 0){
+                if(hasZero) return zeroValue;
+                zeroValue = defaultValue;
+                hasZero = true;
+                return defaultValue;
+            }
+            int mask = this.mask;
+            int index = hash(key) & mask;
+            int[] keys = this.keys;
+            while(keys[index] != 0){
+                if(keys[index] == key){// 键找到
+                    return values[index];
+                }
+                index = (index + 1) & mask;
+            }
+            //键不存在
+            keys[index] = key;
+            values[index] = defaultValue;
+            size++;
+            if(size > maxSize) setCapacity(capacity << 1, loadFactor);
+            return defaultValue;
+        }
+
+        private void setCapacity(int capacity, float loadFactor){
+            capacity = Mathf.nextPowerOfTwo(capacity);
+            this.capacity = capacity;
+            this.loadFactor = loadFactor;
+            maxSize = (int)(capacity * loadFactor);
+            int mask = this.mask = capacity - 1;
+            hashShift = 31 - Integer.numberOfTrailingZeros(capacity);
+
+            int[] oldKeys = keys, oldValues = values;
+            int[] keys = this.keys = new int[capacity];
+            int[] values = this.values = new int[capacity];
+            if(oldKeys == null || oldValues == null) return;
+            for(int i = 0; i < oldKeys.length; i++){
+                if(oldKeys[i] == 0) continue;
+                int index = hash(oldKeys[i]) & mask;
+                while(keys[index] != 0){
+                    index = (index + 1) & mask;
+                }
+                keys[index] = oldKeys[i];
+                values[index] = oldValues[i]; // 插入或更新值
+            }
+        }
+
+        private void clear(){
+            Arrays.fill(keys, 0);
+            Arrays.fill(values, 0);
+            size = 0;
+            hasZero = false;
+        }
+    }
+}
diff --git a/core/src/arc/graphics/g2d/SortedSpriteBatch2.java b/core/src/arc/graphics/g2d/SortedSpriteBatch2.java
new file mode 100644
index 0000000000000000000000000000000000000000..180b04dfead464bca258d4a07d0330259e77393e
--- /dev/null
+++ b/core/src/arc/graphics/g2d/SortedSpriteBatch2.java
@@ -0,0 +1,545 @@
+package arc.graphics.g2d;
+
+import arc.*;
+import arc.graphics.*;
+import arc.graphics.gl.*;
+import arc.math.geom.*;
+import arc.struct.*;
+import arc.util.*;
+
+import java.util.*;
+import java.util.concurrent.*;
+
+//MDTX modified type of requestZ, from float[] to int[]
+//MDTX: sorted requests store in copy(instead write back), reduce one copy and prevent memory fragment
+
+/** Fast sorting implementation written by zxtej. Don't ask me how it works. */
+public class SortedSpriteBatch2 extends SpriteBatch{
+    static ForkJoinHolder commonPool;
+
+    boolean multithreaded = (Core.app.getVersion() >= 21 && !Core.app.isIOS()) || Core.app.isDesktop();
+    int[] contiguous = new int[2048], contiguousCopy = new int[2048];
+    DrawRequest[] copy = new DrawRequest[0];
+    int[] locs = new int[contiguous.length];
+
+    protected DrawRequest[] requests = new DrawRequest[10000];
+    protected boolean sort;
+    protected boolean flushing;
+    protected int[] requestZ = new int[10000];
+    protected int numRequests = 0;
+
+    {
+        for(int i = 0; i < requests.length; i++){
+            requests[i] = new DrawRequest();
+        }
+
+        if(multithreaded){
+            try{
+                commonPool = new ForkJoinHolder();
+            }catch(Throwable t){
+                multithreaded = false;
+            }
+        }
+    }
+
+    @Override
+    protected void setSort(boolean sort){
+        if(this.sort != sort){
+            flush();
+        }
+        this.sort = sort;
+    }
+
+    @Override
+    protected void setShader(Shader shader, boolean apply){
+        if(!flushing && sort){
+            throw new IllegalArgumentException("Shaders cannot be set while sorting is enabled. Set shaders inside Draw.run(...).");
+        }
+        super.setShader(shader, apply);
+    }
+
+    @Override
+    protected void setBlending(Blending blending){
+        this.blending = blending;
+    }
+
+    @Override
+    protected void draw(Texture texture, float[] spriteVertices, int offset, int count){
+        if(sort && !flushing){
+            if(numRequests + count - offset >= this.requests.length) expandRequests();
+            int[] requestZ = this.requestZ;
+            DrawRequest[] requests = this.requests;
+
+            for(int i = offset; i < count; i += SPRITE_SIZE){
+                final DrawRequest req = requests[numRequests];
+                requestZ[numRequests] = Float.floatToRawIntBits((req.z = z) + 16f);
+                System.arraycopy(spriteVertices, i, req.vertices, 0, req.vertices.length);
+                req.texture = texture;
+                req.blending = blending;
+                req.run = null;
+                numRequests++;
+            }
+        }else{
+            super.draw(texture, spriteVertices, offset, count);
+        }
+    }
+
+    @Override
+    protected void draw(TextureRegion region, float x, float y, float originX, float originY, float width, float height, float rotation){
+        if(sort && !flushing){
+            if(numRequests >= requests.length) expandRequests();
+            final DrawRequest req = requests[numRequests];
+            req.x = x;
+            req.y = y;
+            requestZ[numRequests] = Float.floatToRawIntBits((req.z = z) + 16f);
+            req.originX = originX;
+            req.originY = originY;
+            req.width = width;
+            req.height = height;
+            req.color = colorPacked;
+            req.rotation = rotation;
+            req.region.set(region);
+            req.mixColor = mixColorPacked;
+            req.blending = blending;
+            req.texture = null;
+            req.run = null;
+            numRequests++;
+        }else{
+            super.draw(region, x, y, originX, originY, width, height, rotation);
+        }
+    }
+
+    @Override
+    protected void draw(Runnable request){
+        if(sort && !flushing){
+            if(numRequests >= requests.length) expandRequests();
+            final DrawRequest req = requests[numRequests];
+            req.run = request;
+            req.blending = blending;
+            req.mixColor = mixColorPacked;
+            req.color = colorPacked;
+            requestZ[numRequests] = Float.floatToRawIntBits((req.z = z) + 16f);
+            req.texture = null;
+            numRequests++;
+        }else{
+            super.draw(request);
+        }
+    }
+
+    protected void expandRequests(){
+        final DrawRequest[] requests = this.requests, newRequests = new DrawRequest[requests.length * 7 / 4];
+        System.arraycopy(requests, 0, newRequests, 0, Math.min(newRequests.length, requests.length));
+        for(int i = requests.length; i < newRequests.length; i++){
+            newRequests[i] = new DrawRequest();
+        }
+        this.requests = newRequests;
+        this.requestZ = Arrays.copyOf(requestZ, newRequests.length);
+    }
+
+    @Override
+    protected void flush(){
+        flushRequests();
+        super.flush();
+    }
+
+    protected void flushRequests(){
+        if(!flushing && numRequests > 0){
+            flushing = true;
+            sortRequests();
+            float preColor = colorPacked, preMixColor = mixColorPacked;
+            Blending preBlending = blending;
+
+            DrawRequest[] r = copy;//MDTX: 'copy' instead requests
+            int num = numRequests;
+            for(int j = 0; j < num; j++){
+                final DrawRequest req = r[j];
+
+                colorPacked = req.color;
+                mixColorPacked = req.mixColor;
+
+                super.setBlending(req.blending);
+
+                if(req.run != null){
+                    req.run.run();
+                    req.run = null;
+                }else if(req.texture != null){
+                    super.draw(req.texture, req.vertices, 0, req.vertices.length);
+                }else{
+                    super.draw(req.region, req.x, req.y, req.originX, req.originY, req.width, req.height, req.rotation);
+                }
+            }
+
+            colorPacked = preColor;
+            mixColorPacked = preMixColor;
+            color.abgr8888(colorPacked);
+            mixColor.abgr8888(mixColorPacked);
+            blending = preBlending;
+
+            numRequests = 0;
+
+            flushing = false;
+        }
+    }
+
+    protected void sortRequests(){
+        if(multithreaded){
+            sortRequestsThreaded();
+        }else{
+            sortRequestsStandard();
+        }
+    }
+
+    protected void sortRequestsThreaded(){
+        final int numRequests = this.numRequests;
+        final int[] itemZ = requestZ;
+
+        int[] contiguous = this.contiguous;
+        int ci = 0, cl = contiguous.length;
+        int z = itemZ[0];
+        int startI = 0;
+        // Point3: <z, index, length>
+        for(int i = 1; i < numRequests; i++){
+            if(itemZ[i] != z){ // if contiguous section should end
+                contiguous[ci] = z;
+                contiguous[ci + 1] = startI;
+                contiguous[ci + 2] = i - startI;
+                ci += 3;
+                if(ci + 3 > cl){
+                    contiguous = Arrays.copyOf(contiguous, cl <<= 1);
+                }
+                z = itemZ[startI = i];
+            }
+        }
+        contiguous[ci] = z;
+        contiguous[ci + 1] = startI;
+        contiguous[ci + 2] = numRequests - startI;
+        this.contiguous = contiguous;
+
+        final int L = (ci / 3) + 1;
+
+        if(contiguousCopy.length < contiguous.length) this.contiguousCopy = new int[contiguous.length];
+
+        final int[] sorted = CountingSort.countingSortMapMT(contiguous, contiguousCopy, L);
+
+        if(locs.length < L + 1) locs = new int[L + L / 10];
+        if(copy.length < numRequests) copy = new DrawRequest[numRequests + (numRequests >> 3)];
+        final int[] locs = this.locs;
+        for(int i = 0; i < L; i++){
+            locs[i + 1] = locs[i] + sorted[i * 3 + 2];
+        }
+        PopulateTask.tasks = sorted;
+        PopulateTask.src = requests;
+        PopulateTask.dest = copy;
+        PopulateTask.locs = locs;
+        commonPool.pool.invoke(new PopulateTask(0, L));
+    }
+
+    protected void sortRequestsStandard(){ // Non-threaded implementation for weak devices
+        final int numRequests = this.numRequests;
+        final int[] itemZ = requestZ;
+        int[] contiguous = this.contiguous;
+        int ci = 0, cl = contiguous.length;
+        int z = itemZ[0];
+        int startI = 0;
+        // Point3: <z, index, length>
+        for(int i = 1; i < numRequests; i++){
+            if(itemZ[i] != z){ // if contiguous section should end
+                contiguous[ci] = z;
+                contiguous[ci + 1] = startI;
+                contiguous[ci + 2] = i - startI;
+                ci += 3;
+                if(ci + 3 > cl){
+                    contiguous = Arrays.copyOf(contiguous, cl <<= 1);
+                }
+                z = itemZ[startI = i];
+            }
+        }
+        contiguous[ci] = Float.floatToRawIntBits(z + 16f);
+        contiguous[ci + 1] = startI;
+        contiguous[ci + 2] = numRequests - startI;
+        this.contiguous = contiguous;
+
+        final int L = (ci / 3) + 1;
+
+        if(contiguousCopy.length < contiguous.length) contiguousCopy = new int[contiguous.length];
+
+        final int[] sorted = CountingSort.countingSortMap(contiguous, contiguousCopy, L);
+
+        if(copy.length < numRequests) copy = new DrawRequest[numRequests + (numRequests >> 3)];
+        int ptr = 0;
+        final DrawRequest[] items = requests, dest = copy;
+        for(int i = 0; i < L * 3; i += 3){
+            final int pos = sorted[i + 1], length = sorted[i + 2];
+            if(length < 10){
+                final int end = pos + length;
+                for(int sj = pos, dj = ptr; sj < end; sj++, dj++){
+                    dest[dj] = items[sj];
+                }
+            }else System.arraycopy(items, pos, dest, ptr, Math.min(length, dest.length - ptr));
+            ptr += length;
+        }
+    }
+
+    static class CountingSort{
+        private static final int processors = Runtime.getRuntime().availableProcessors() * 8;
+
+        static int[] locs = new int[100];
+        static final int[][] locses = new int[processors][100];
+
+        static final IntIntMap[] countses = new IntIntMap[processors];
+
+        private static Point2[] entries = new Point2[100];
+
+        private static int[] entries3 = new int[300], entries3a = new int[300];
+        private static Integer[] entriesBacking = new Integer[100];
+
+        private static final CountingSortTask[] tasks = new CountingSortTask[processors];
+        private static final CountingSortTask2[] task2s = new CountingSortTask2[processors];
+        private static final Future<?>[] futures = new Future<?>[processors];
+
+        static{
+            for(int i = 0; i < countses.length; i++) countses[i] = new IntIntMap();
+            for(int i = 0; i < entries.length; i++) entries[i] = new Point2();
+
+            for(int i = 0; i < processors; i++){
+                tasks[i] = new CountingSortTask();
+                task2s[i] = new CountingSortTask2();
+            }
+        }
+
+        static class CountingSortTask implements Runnable{
+            static int[] arr;
+            int start, end, id;
+
+            public void set(int start, int end, int id){
+                this.start = start;
+                this.end = end;
+                this.id = id;
+            }
+
+            @Override
+            public void run(){
+                final int id = this.id, start = this.start, end = this.end;
+                int[] locs = locses[id];
+                final int[] arr = CountingSortTask.arr;
+                final IntIntMap counts = countses[id];
+                counts.clear();
+                int unique = 0;
+                for(int i = start; i < end; i++){
+                    int loc = counts.getOrPut(arr[i * 3], unique);
+                    arr[i * 3] = loc;
+                    if(loc == unique){
+                        if(unique >= locs.length){
+                            locs = Arrays.copyOf(locs, unique * 3 / 2);
+                        }
+                        locs[unique++] = 1;
+                    }else{
+                        locs[loc]++;
+                    }
+                }
+                locses[id] = locs;
+            }
+        }
+
+        static class CountingSortTask2 implements Runnable{
+            static int[] src, dest;
+            int start, end, id;
+
+            public void set(int start, int end, int id){
+                this.start = start;
+                this.end = end;
+                this.id = id;
+            }
+
+            @Override
+            public void run(){
+                final int start = this.start, end = this.end;
+                final int[] locs = locses[id];
+                final int[] src = CountingSortTask2.src, dest = CountingSortTask2.dest;
+                for(int i = end - 1, i3 = i * 3; i >= start; i--, i3 -= 3){
+                    final int destPos = --locs[src[i3]] * 3;
+                    dest[destPos] = src[i3];
+                    dest[destPos + 1] = src[i3 + 1];
+                    dest[destPos + 2] = src[i3 + 2];
+                }
+            }
+        }
+
+        static int[] countingSortMapMT(final int[] arr, final int[] swap, final int end){
+            final IntIntMap[] countses = CountingSort.countses;
+            final int[][] locs = CountingSort.locses;
+            final int threads = Math.min(processors, (end + 4095) / 4096); // 4096 Point3s to process per thread
+            final int thread_size = end / threads + 1;
+            final CountingSortTask[] tasks = CountingSort.tasks;
+            final CountingSortTask2[] task2s = CountingSort.task2s;
+            final Future<?>[] futures = CountingSort.futures;
+            CountingSortTask.arr = CountingSortTask2.src = arr;
+            CountingSortTask2.dest = swap;
+
+            for(int s = 0, thread = 0; thread < threads; thread++, s += thread_size){
+                CountingSortTask task = tasks[thread];
+                final int stop = Math.min(s + thread_size, end);
+                task.set(s, stop, thread);
+                task2s[thread].set(s, stop, thread);
+                futures[thread] = commonPool.pool.submit(task);
+            }
+
+            int unique = 0;
+            for(int i = 0; i < threads; i++){
+                try{
+                    futures[i].get();
+                }catch(ExecutionException | InterruptedException e){
+                    commonPool.pool.execute(tasks[i]);
+                }
+                unique += countses[i].size;
+            }
+
+            final int L = unique;
+            if(entriesBacking.length < L){
+                entriesBacking = new Integer[L * 3 / 2];
+                entries3 = new int[L * 3 * 3 / 2];
+                entries3a = new int[L * 3 * 3 / 2];
+            }
+            final int[] entries = CountingSort.entries3, entries3a = CountingSort.entries3a;
+            final Integer[] entriesBacking = CountingSort.entriesBacking;
+            int j = 0;
+            for(int i = 0; i < threads; i++){
+                if(countses[i].size == 0) continue;
+                final IntIntMap.Entries countEntries = countses[i].entries();
+                final IntIntMap.Entry entry = countEntries.next();
+                entries[j] = entry.key;
+                entries[j + 1] = entry.value;
+                entries[j + 2] = i;
+                j += 3;
+                while(countEntries.hasNext){
+                    countEntries.next();
+                    entries[j] = entry.key;
+                    entries[j + 1] = entry.value;
+                    entries[j + 2] = i;
+                    j += 3;
+                }
+            }
+
+            for(int i = 0; i < L; i++){
+                entriesBacking[i] = i;
+            }
+            Arrays.sort(entriesBacking, 0, L, Structs.comparingInt(i -> entries[i * 3]));
+            for(int i = 0; i < L; i++){
+                int from = entriesBacking[i] * 3, to = i * 3;
+                entries3a[to] = entries[from];
+                entries3a[to + 1] = entries[from + 1];
+                entries3a[to + 2] = entries[from + 2];
+            }
+
+            for(int i = 0, pos = 0; i < L * 3; i += 3){
+                pos = (locs[entries3a[i + 2]][entries3a[i + 1]] += pos);
+            }
+
+            for(int thread = 0; thread < threads; thread++){
+                futures[thread] = commonPool.pool.submit(task2s[thread]);
+            }
+            for(int i = 0; i < threads; i++){
+                try{
+                    futures[i].get();
+                }catch(ExecutionException | InterruptedException e){
+                    commonPool.pool.execute(task2s[i]);
+                }
+            }
+            return swap;
+        }
+
+        static int[] countingSortMap(final int[] arr, final int[] swap, final int end){
+            int[] locs = CountingSort.locs;
+            final IntIntMap counts = CountingSort.countses[0];
+            counts.clear();
+
+            int unique = 0;
+            final int end3 = end * 3;
+            for(int i = 0; i < end3; i += 3){
+                int loc = counts.getOrPut(arr[i], unique);
+                arr[i] = loc;
+                if(loc == unique){
+                    if(unique >= locs.length){
+                        locs = Arrays.copyOf(locs, unique * 3 / 2);
+                    }
+                    locs[unique++] = 1;
+                }else{
+                    locs[loc]++;
+                }
+            }
+            CountingSort.locs = locs;
+
+            if(entries.length < unique){
+                final int prevLength = entries.length;
+                entries = Arrays.copyOf(entries, unique * 3 / 2);
+                final Point2[] entries = CountingSort.entries;
+                for(int i = prevLength; i < entries.length; i++) entries[i] = new Point2();
+            }
+            final Point2[] entries = CountingSort.entries;
+
+            final IntIntMap.Entries countEntries = counts.entries();
+            final IntIntMap.Entry entry = countEntries.next();
+            entries[0].set(entry.key, entry.value);
+            int j = 1;
+            while(countEntries.hasNext){
+                countEntries.next(); // it returns the same entry over and over again.
+                entries[j++].set(entry.key, entry.value);
+            }
+            Arrays.sort(entries, 0, unique, Structs.comparingInt(p -> p.x));
+
+            int prev = entries[0].y, next;
+            for(int i = 1; i < unique; i++){
+                locs[next = entries[i].y] += locs[prev];
+                prev = next;
+            }
+            for(int i = end - 1, i3 = i * 3; i >= 0; i--, i3 -= 3){
+                final int destPos = --locs[arr[i3]] * 3;
+                swap[destPos] = arr[i3];
+                swap[destPos + 1] = arr[i3 + 1];
+                swap[destPos + 2] = arr[i3 + 2];
+            }
+            return swap;
+        }
+    }
+
+    static class PopulateTask extends RecursiveAction{
+        int from, to;
+        static int[] tasks;
+        static DrawRequest[] src;
+        static DrawRequest[] dest;
+        static int[] locs;
+
+        //private static final int threshold = 256;
+        PopulateTask(int from, int to){
+            this.from = from;
+            this.to = to;
+        }
+
+        @Override
+        protected void compute(){
+            final int[] locs = PopulateTask.locs;
+            if(to - from > 1 && locs[to] - locs[from] > 2048){
+                final int half = (locs[to] + locs[from]) >> 1;
+                int mid = Arrays.binarySearch(locs, from, to, half);
+                if(mid < 0) mid = -mid - 1;
+                if(mid != from && mid != to){
+                    invokeAll(new PopulateTask(from, mid), new PopulateTask(mid, to));
+                    return;
+                }
+            }
+            final DrawRequest[] src = PopulateTask.src, dest = PopulateTask.dest;
+            final int[] tasks = PopulateTask.tasks;
+            for(int i = from; i < to; i++){
+                final int point = i * 3, pos = tasks[point + 1], length = tasks[point + 2];
+                if(length < 10){
+                    final int end = pos + length;
+                    for(int sj = pos, dj = locs[i]; sj < end; sj++, dj++){
+                        dest[dj] = src[sj];
+                    }
+                }else{
+                    System.arraycopy(src, pos, dest, locs[i], Math.min(length, dest.length - locs[i]));
+                }
+            }
+        }
+    }
+}
diff --git a/core/src/mindustry/ClientLauncher.java b/core/src/mindustry/ClientLauncher.java
index 07bdf28dbea6e898073a713e08a137c278831acb..27b78ed880bd4e43f96640ffde8fa5bba9f86c14 100644
--- a/core/src/mindustry/ClientLauncher.java
+++ b/core/src/mindustry/ClientLauncher.java
@@ -20,7 +20,6 @@ import mindustry.maps.*;
 import mindustry.mod.*;
 import mindustry.net.*;
 import mindustry.ui.*;
-import mindustryX.features.*;
 
 import static arc.Core.*;
 import static mindustry.Vars.*;
@@ -72,15 +71,7 @@ public abstract class ClientLauncher extends ApplicationCore implements Platform
 
         UI.loadColors();
         //MDTX: add numRequests count.
-        batch = new SortedSpriteBatch(){
-            @Override
-            protected void flushRequests(){
-                if(!flushing){
-                    DebugUtil.lastDrawRequests += numRequests;
-                }
-                super.flushRequests();
-            }
-        };
+        batch = new MySortedSpriteBatch();
         assets = new AssetManager();
         assets.setLoader(Texture.class, "." + mapExtension, new MapPreviewLoader());
 
diff --git a/core/src/mindustryX/features/RenderExt.java b/core/src/mindustryX/features/RenderExt.java
index d969283650b2ac2ed75a235dd66476cd86255349..8fe579de4d1f57e40be3926e9be95f88ab873aab 100644
--- a/core/src/mindustryX/features/RenderExt.java
+++ b/core/src/mindustryX/features/RenderExt.java
@@ -30,6 +30,7 @@ public class RenderExt{
     public static float overdriveZoneTransparency;
     public static boolean logicDisplayNoBorder, arcDrillMode;
     public static int blockRenderLevel;
+    public static boolean renderSort;
 
     public static boolean unitHide = false;
 
@@ -60,6 +61,7 @@ public class RenderExt{
             logicDisplayNoBorder = Core.settings.getBool("arclogicbordershow");
             arcDrillMode = Core.settings.getBool("arcdrillmode");
             blockRenderLevel = Core.settings.getInt("blockRenderLevel");
+            renderSort = Core.settings.getBool("renderSort");
         });
         Events.run(Trigger.draw, RenderExt::draw);
         Events.on(TileChangeEvent.class, RenderExt::onSetBlock);
diff --git a/core/src/mindustryX/features/Settings.java b/core/src/mindustryX/features/Settings.java
index b5f1cdc56623e5ad56e340da6d47a73eb490e5d1..22d9c9119ae16928b545f1059bcfa8b59b6293a5 100644
--- a/core/src/mindustryX/features/Settings.java
+++ b/core/src/mindustryX/features/Settings.java
@@ -63,6 +63,9 @@ public class Settings{
             c.addCategory("entitySettings");
             c.checkPref("bulletShow", true);
             c.checkPref("showMineBeam".toLowerCase(), true);
+
+            c.addCategory("developerMode");
+            c.checkPref("renderSort", false);
         }));
         ArcOld.init(categories);
         Events.on(ClientLoadEvent.class, e -> {
