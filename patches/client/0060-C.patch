From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MinRi2 <2275045670@qq.com>
Date: Sat, 20 Apr 2024 20:34:21 +0800
Subject: [PATCH] =?UTF-8?q?C:=20=E6=96=B0=E5=88=B6=E6=A0=B8=E5=BF=83?=
 =?UTF-8?q?=E8=B5=84=E6=BA=90=E6=98=BE=E7=A4=BA?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

物品平均变化量;建造耗量重排

优化代码与显示；修复Plan灰框bug；移除物品平均值
way-zer <himc.wicp@gmail.com> on 2024/4/30 at 0:09

拆除建筑，续建建筑显示oh no图标
MinRi2 <2275045670@qq.com> on 2024/5/4 at 15:25

优化显示效果;更紧凑的Item布局
way-zer <himc.wicp@gmail.com> on 2024/5/17 at 20:50
---
 .../mindustry/ui/fragments/HudFragment.java   |  11 +-
 .../features/ui/NewCoreItemsDisplay.java      | 245 ++++++++++++++++++
 2 files changed, 249 insertions(+), 7 deletions(-)
 create mode 100644 core/src/mindustryX/features/ui/NewCoreItemsDisplay.java

diff --git a/core/src/mindustry/ui/fragments/HudFragment.java b/core/src/mindustry/ui/fragments/HudFragment.java
index 6f8bb852edfe397c4abbbe9268f8b5648c19add3..37a57b425a423ddff029268c938423f6711340c8 100644
--- a/core/src/mindustry/ui/fragments/HudFragment.java
+++ b/core/src/mindustry/ui/fragments/HudFragment.java
@@ -30,6 +30,7 @@ import mindustry.ui.*;
 import mindustry.world.blocks.storage.*;
 import mindustry.world.blocks.storage.CoreBlock.*;
 import mindustryX.features.*;
+import mindustryX.features.ui.*;
 
 import static mindustry.Vars.*;
 import static mindustry.gen.Tex.*;
@@ -41,7 +42,7 @@ public class HudFragment{
     public boolean shown = true;
 
     private ImageButton flip;
-    private CoreItemsDisplay coreItems = new CoreItemsDisplay();
+    public NewCoreItemsDisplay coreItems = new NewCoreItemsDisplay();
 
     private String hudText = "";
     private boolean showHudText;
@@ -89,11 +90,6 @@ public class HudFragment{
             showToast(Icon.warning, Core.bundle.format("sector.attacked", e.sector.name()));
         });
 
-        Events.on(ResetEvent.class, e -> {
-            coreItems.resetUsed();
-            coreItems.clear();
-        });
-
         //paused table
         parent.fill(t -> {
             t.name = "paused";
@@ -318,8 +314,9 @@ public class HudFragment{
             t.collapser(v -> v.add().height(pauseHeight), () -> state.isPaused() && !netServer.isWaitingForPlayers()).row();
 
             t.table(c -> {
+                c.touchable = Touchable.disabled;
                 //core items
-                c.top().collapser(coreItems, () -> Core.settings.getBool("coreitems") && !mobile && shown).fillX().row();
+                c.top().add(coreItems).fillX().row();
 
                 float notifDuration = 240f;
                 float[] coreAttackTime = {0};
diff --git a/core/src/mindustryX/features/ui/NewCoreItemsDisplay.java b/core/src/mindustryX/features/ui/NewCoreItemsDisplay.java
new file mode 100644
index 0000000000000000000000000000000000000000..d51e2f8f410239be0924c45ea5471edbda7d71ee
--- /dev/null
+++ b/core/src/mindustryX/features/ui/NewCoreItemsDisplay.java
@@ -0,0 +1,245 @@
+package mindustryX.features.ui;
+
+import arc.*;
+import arc.graphics.*;
+import arc.scene.ui.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import arc.util.*;
+import mindustry.core.*;
+import mindustry.entities.*;
+import mindustry.game.EventType.*;
+import mindustry.graphics.*;
+import mindustry.type.*;
+import mindustry.ui.*;
+import mindustry.world.*;
+import mindustry.world.blocks.ConstructBlock.*;
+import mindustry.world.blocks.power.*;
+import mindustry.world.blocks.storage.*;
+
+import java.util.*;
+
+import static mindustry.Vars.*;
+
+//moved from mindustry.arcModule.ui.RCoreItemsDisplay
+public class NewCoreItemsDisplay extends Table{
+    public static final float MIN_WIDTH = 64f;
+
+    private Table itemsTable, unitsTable, plansTable;
+
+    private static final Interval timer = new Interval(2);
+    private int columns = -1;
+
+    private final int[] itemDelta;
+    private final int[] lastItemAmount;
+    private final ObjectSet<Item> usedItems = new ObjectSet<>();
+    private final ObjectSet<UnitType> usedUnits = new ObjectSet<>();
+
+    private final ItemSeq planItems = new ItemSeq();
+    private final ObjectIntMap<Block> planCounter = new ObjectIntMap<>();
+
+    public NewCoreItemsDisplay(){
+        itemDelta = new int[content.items().size];
+        lastItemAmount = new int[content.items().size];
+        Events.on(ResetEvent.class, e -> {
+            usedItems.clear();
+            usedUnits.clear();
+            Arrays.fill(itemDelta, 0);
+            Arrays.fill(lastItemAmount, 0);
+            itemsTable.clearChildren();
+            unitsTable.clearChildren();
+            plansTable.clearChildren();
+        });
+
+        setup();
+    }
+
+    private void setup(){
+        itemsTable = new Table(Styles.black3);
+        unitsTable = new Table(Styles.black3);
+        plansTable = new Table(Styles.black3);
+
+        var itemCol = add(new SimpleCollapser(itemsTable, true)).growX().get();
+        var unitsCol = row().add(new SimpleCollapser(unitsTable, true)).growX().get();
+        var emptyLine = row().add();
+        var plansCol = row().add(new SimpleCollapser(plansTable, true)).growX().get();
+        update(() -> {
+            var columns = Core.settings.getInt("arcCoreItemsCol");
+            int displayType = Core.settings.getInt("arccoreitems");
+            itemCol.setCollapsed(displayType != 1 && displayType != 3);
+            unitsCol.setCollapsed(displayType != 2 && displayType != 3);
+            plansCol.setCollapsed(displayType < 1);
+            var newHeight = plansTable.hasChildren() ? 12f : 0f;
+            if(emptyLine.maxHeight() != newHeight){
+                emptyLine.height(newHeight);
+                emptyLine.getTable().invalidate();
+            }
+
+            if(this.columns != columns){
+                this.columns = columns;
+                rebuildItems();
+                rebuildUnits();
+                rebuildPlans();
+            }
+        });
+
+        itemsTable.update(() -> {
+            updateItemMeans();
+            if(content.items().contains(item -> player.team().items().get(item) > 0 && usedItems.add(item))){
+                rebuildItems();
+            }
+        });
+        unitsTable.update(() -> {
+            if(content.units().contains(unit -> player.team().data().countType(unit) > 0 && usedUnits.add(unit))){
+                rebuildUnits();
+            }
+        });
+        plansTable.update(() -> {
+            if(timer.get(1, 10f)){
+                rebuildPlans();
+            }
+        });
+    }
+
+    private void updateItemMeans(){
+        if(!timer.get(0, 60f)) return;
+        var items = player.team().items();
+        for(Item item : usedItems){
+            short id = item.id;
+            int coreAmount = items.get(id);
+            int lastAmount = lastItemAmount[id];
+            itemDelta[id] = coreAmount - lastAmount;
+            lastItemAmount[id] = coreAmount;
+        }
+    }
+
+    private void rebuildItems(){
+        itemsTable.clearChildren();
+        if(player.team().core() == null) return;
+
+        int i = 0;
+        for(Item item : content.items()){
+            if(!usedItems.contains(item)){
+                continue;
+            }
+
+            itemsTable.stack(
+            new Table(t ->
+            t.image(item.uiIcon).size(iconMed - 4).scaling(Scaling.fit).pad(2f)
+            .tooltip(tooltip -> tooltip.background(Styles.black6).margin(4f).add(item.localizedName).style(Styles.outlineLabel))
+            ),
+            new Table(t -> t.label(() -> {
+                int update = itemDelta[item.id];
+                if(update == 0) return "";
+                return (update < 0 ? "[red]" : "[green]+") + UI.formatAmount(update);
+            }).fontScale(0.85f)).top().left()
+            );
+
+            itemsTable.table(amountTable -> {
+                amountTable.defaults().expand().left();
+
+                Label amountLabel = amountTable.add("").growY().get();
+                amountTable.row();
+                var planLabel = amountTable.add("").fontScale(0.6f).height(0.01f);
+
+                amountTable.update(() -> {
+                    int planAmount = planItems.get(item);
+                    int amount = player.team().items().get(item);
+
+                    float newFontScale = 1f;
+                    Color amountColor = Color.white;
+                    if(planAmount == 0){
+                        var core = player.team().core();
+                        if(core != null && amount >= core.storageCapacity * 0.99){
+                            amountColor = Pal.accent;
+                        }
+                        planLabel.height(0.01f);//can't use 0 as maxHeight;
+                        planLabel.get().setText("");
+                    }else{
+                        amountColor = (amount > planAmount ? Color.green
+                        : amount > planAmount / 2 ? Pal.stat
+                        : Color.scarlet);
+                        planLabel.height(Float.NEGATIVE_INFINITY);
+                        planLabel.color(planAmount > 0 ? Color.scarlet : Color.green);
+                        planLabel.get().setText(UI.formatAmount(planAmount));
+                        newFontScale = 0.7f;
+                    }
+
+                    if(amountLabel.getFontScaleX() != newFontScale)
+                        amountLabel.setFontScale(newFontScale);
+                    amountLabel.setColor(amountColor);
+                    amountLabel.setText(UI.formatAmount(amount));
+                });
+            }).minWidth(MIN_WIDTH).left();
+
+            if(++i % columns == 0){
+                itemsTable.row();
+            }
+        }
+    }
+
+    private void rebuildUnits(){
+        unitsTable.clearChildren();
+
+        int i = 0;
+        for(UnitType unit : content.units()){
+            if(usedUnits.contains(unit)){
+                unitsTable.image(unit.uiIcon).size(iconSmall).scaling(Scaling.fit).pad(2f)
+                .tooltip(t -> t.background(Styles.black6).margin(4f).add(unit.localizedName).style(Styles.outlineLabel));
+                unitsTable.label(() -> {
+                    int typeCount = player.team().data().countType(unit);
+                    return (typeCount == Units.getCap(player.team()) ? "[stat]" : "") + typeCount;
+                }).minWidth(MIN_WIDTH).left();
+
+                if(++i % columns == 0){
+                    unitsTable.row();
+                }
+            }
+        }
+    }
+
+    private void rebuildPlans(){
+        planItems.clear();
+        planCounter.clear();
+
+        control.input.allPlans().each(plan -> {
+            Block block = plan.block;
+
+            if(block instanceof CoreBlock) return;
+
+            if(plan.build() instanceof ConstructBuild build){
+                block = build.current;
+            }
+
+            planCounter.increment(block, plan.breaking ? -1 : 1);
+
+            for(ItemStack stack : block.requirements){
+                int planAmount = (int)(plan.breaking ? -state.rules.buildCostMultiplier * state.rules.deconstructRefundMultiplier * stack.amount * plan.progress
+                : state.rules.buildCostMultiplier * stack.amount * (1 - plan.progress));
+                planItems.add(stack.item, planAmount);
+            }
+        });
+
+        plansTable.clearChildren();
+        if(planCounter.isEmpty()) return;
+        int i = 0;
+        for(Block block : content.blocks()){
+            int count = planCounter.get(block, 0);
+            if(count == 0 || block.category == Category.distribution && block.size < 3
+            || block.category == Category.liquid && block.size < 3
+            || block instanceof PowerNode
+            || block instanceof BeamNode) continue;
+
+            plansTable.image(block.uiIcon).size(iconSmall).scaling(Scaling.fit).pad(2f);
+            plansTable.label(() -> (count > 0 ? "[green]+" : "[red]") + count).minWidth(MIN_WIDTH).left();
+
+            if(++i % columns == 0){
+                plansTable.row();
+            }
+        }
+    }
+
+    public boolean hadItem(Item item){
+        return usedItems.contains(item);
+    }
+}
