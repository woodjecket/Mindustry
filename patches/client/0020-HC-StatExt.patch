From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: way-zer <himc.wicp@gmail.com>
Date: Sun, 18 Feb 2024 03:08:37 +0800
Subject: [PATCH] HC: StatExt
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

修复一些显示错误
way-zer <himc.wicp@gmail.com> on 2024/5/4 at 22:17
---
 core/src/mindustry/type/Item.java             |   5 +
 core/src/mindustry/type/Liquid.java           |   2 +
 core/src/mindustry/type/StatusEffect.java     |   2 +
 core/src/mindustry/type/UnitType.java         |  37 ++-
 core/src/mindustry/type/Weapon.java           |  12 +
 core/src/mindustry/world/Block.java           |   4 +-
 .../world/blocks/defense/ForceProjector.java  |   7 +-
 .../world/blocks/defense/MendProjector.java   |   6 +-
 .../world/blocks/defense/RegenProjector.java  |   5 +-
 .../world/blocks/defense/ShieldWall.java      |   4 +
 .../defense/turrets/PointDefenseTurret.java   |   1 +
 .../distribution/BufferedItemBridge.java      |   9 +
 .../world/blocks/distribution/Junction.java   |  10 +
 .../world/blocks/power/ImpactReactor.java     |  17 ++
 .../world/blocks/production/Drill.java        |   5 +-
 .../world/blocks/sandbox/PowerSource.java     |   6 +
 .../world/blocks/sandbox/PowerVoid.java       |   1 -
 .../world/consumers/ConsumeItemDynamic.java   |   2 +-
 .../world/consumers/ConsumeItems.java         |   2 +-
 .../consumers/ConsumePayloadDynamic.java      |   2 +-
 core/src/mindustry/world/meta/Stat.java       |  21 +-
 core/src/mindustry/world/meta/StatCat.java    |   5 +-
 core/src/mindustry/world/meta/StatValues.java | 261 ++++++++++++++----
 23 files changed, 346 insertions(+), 80 deletions(-)

diff --git a/core/src/mindustry/type/Item.java b/core/src/mindustry/type/Item.java
index 5d81790919f016776eff80c6d241b1d034f76d11..ff81bc3b9d0a54e7aa0e8dae9e12d48612a9d2ab 100644
--- a/core/src/mindustry/type/Item.java
+++ b/core/src/mindustry/type/Item.java
@@ -12,6 +12,7 @@ import mindustry.graphics.MultiPacker.*;
 import mindustry.logic.*;
 import mindustry.world.blocks.environment.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -112,6 +113,10 @@ public class Item extends UnlockableContent implements Senseable{
         stats.addPercent(Stat.flammability, flammability);
         stats.addPercent(Stat.radioactivity, radioactivity);
         stats.addPercent(Stat.charge, charge);
+        stats.add(StatExt.cost, cost);
+        stats.add(StatExt.hardness, hardness);
+        stats.add(StatExt.healthScaling,healthScaling);
+        stats.add(StatExt.buildable,buildable);
     }
 
     @Override
diff --git a/core/src/mindustry/type/Liquid.java b/core/src/mindustry/type/Liquid.java
index 9032b4bf9bdcacd31826eb95fedc7781465cc87a..ccb3c4b63be9aebc1c66f1003e4b17f10db1a2d7 100644
--- a/core/src/mindustry/type/Liquid.java
+++ b/core/src/mindustry/type/Liquid.java
@@ -13,6 +13,7 @@ import mindustry.graphics.*;
 import mindustry.logic.*;
 import mindustry.world.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.entities.Puddles.*;
 
@@ -165,6 +166,7 @@ public class Liquid extends UnlockableContent implements Senseable{
         stats.addPercent(Stat.temperature, temperature);
         stats.addPercent(Stat.heatCapacity, heatCapacity);
         stats.addPercent(Stat.viscosity, viscosity);
+        stats.add(StatExt.boilPoint,boilPoint);
     }
 
     @Override
diff --git a/core/src/mindustry/type/StatusEffect.java b/core/src/mindustry/type/StatusEffect.java
index e344f652f0c1f9993d401ea225e56a3edb780514..a211cc0968ac9ba4911efc26a7b2167ce5cfbc16 100644
--- a/core/src/mindustry/type/StatusEffect.java
+++ b/core/src/mindustry/type/StatusEffect.java
@@ -13,6 +13,7 @@ import mindustry.gen.*;
 import mindustry.graphics.*;
 import mindustry.graphics.MultiPacker.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 public class StatusEffect extends UnlockableContent{
     /** Damage dealt by the unit with the effect. */
@@ -95,6 +96,7 @@ public class StatusEffect extends UnlockableContent{
         if(speedMultiplier != 1) stats.addPercent(Stat.speedMultiplier, speedMultiplier);
         if(reloadMultiplier != 1) stats.addPercent(Stat.reloadMultiplier, reloadMultiplier);
         if(buildSpeedMultiplier != 1) stats.addPercent(Stat.buildSpeedMultiplier, buildSpeedMultiplier);
+        if(dragMultiplier != 1) stats.addPercent(StatExt.dragMultiplier, dragMultiplier);
         if(damage > 0) stats.add(Stat.damage, damage * 60f, StatUnit.perSecond);
         if(damage < 0) stats.add(Stat.healing, -damage * 60f, StatUnit.perSecond);
 
diff --git a/core/src/mindustry/type/UnitType.java b/core/src/mindustry/type/UnitType.java
index c12e1309e20cd23bc16fb8c94c2122be84dff073..057f958d2537aa819afc47534e465d1f83ec64d9 100644
--- a/core/src/mindustry/type/UnitType.java
+++ b/core/src/mindustry/type/UnitType.java
@@ -37,6 +37,7 @@ import mindustry.world.blocks.payloads.*;
 import mindustry.world.blocks.units.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static arc.graphics.g2d.Draw.*;
 import static mindustry.Vars.*;
@@ -618,29 +619,47 @@ public class UnitType extends UnlockableContent implements Senseable{
         stats.add(Stat.health, health);
         stats.add(Stat.armor, armor);
         stats.add(Stat.speed, speed * 60f / tilesize, StatUnit.tilesSecond);
+        stats.add(StatExt.rotateSpeed, rotateSpeed);
         stats.add(Stat.size, StatValues.squared(hitSize / tilesize, StatUnit.blocks));
         stats.add(Stat.itemCapacity, itemCapacity);
         stats.add(Stat.range, (int)(maxRange / tilesize), StatUnit.blocks);
         stats.add(Stat.targetsAir, targetAir);
         stats.add(Stat.targetsGround, targetGround);
+        stats.add(StatExt.unitItemCapacity, itemCapacity);
+        stats.add(StatExt.aiController,aiController.get().getClass().getSimpleName());
 
         if(abilities.any()){
-            stats.add(Stat.abilities, StatValues.abilities(abilities));
+            stats.add(Stat.abilities, StatValues.abilities(this, abilities));
+        }
+
+        stats.add(StatExt.unitrange, (int)(maxRange / tilesize), StatUnit.blocks);
+        stats.add(StatExt.estimateDPS,estimateDps());
+        stats.add(StatExt.ammoType, ammoType.icon());
+        stats.add(StatExt.ammoCapacity, ammoCapacity);
+        if (crushDamage > 0) {
+            stats.add(StatExt.crushDamage, crushDamage * 60f, StatUnit.perSecond);
         }
 
         stats.add(Stat.flying, flying);
 
         if(!flying){
             stats.add(Stat.canBoost, canBoost);
+            if(canBoost && boostMultiplier != 1){
+                stats.add(StatExt.boostMultiplier, boostMultiplier);
+            }
+        }
+        if(drownTimeMultiplier != 1){
+            stats.add(StatExt.drownTimeMultiplier, drownTimeMultiplier);
         }
 
         if(mineTier >= 1){
+            stats.add(StatExt.mineLevel, "@级", mineTier);
             stats.addPercent(Stat.mineSpeed, mineSpeed);
-            stats.add(Stat.mineTier, StatValues.drillables(mineSpeed, 1f, 1, null, b ->
-                b.itemDrop != null &&
-                (b instanceof Floor f && (((f.wallOre && mineWalls) || (!f.wallOre && mineFloor))) ||
-                (!(b instanceof Floor) && mineWalls)) &&
-                b.itemDrop.hardness <= mineTier && (!b.playerUnmineable || Core.settings.getBool("doubletapmine"))));
+            stats.add(Stat.mineTier, StatValues.drillables(mineHardnessScaling ? 50 : 65, mineHardnessScaling ? 1 : 0, mineSpeed, null, b ->
+            b.itemDrop != null &&
+            (b instanceof Floor f && (((f.wallOre && mineWalls) || (!f.wallOre && mineFloor))) ||
+            (!(b instanceof Floor) && mineWalls)) &&
+            b.itemDrop.hardness <= mineTier && (!b.playerUnmineable || Core.settings.getBool("doubletapmine"))));
         }
         if(buildSpeed > 0){
             stats.addPercent(Stat.buildSpeed, buildSpeed);
@@ -659,6 +678,10 @@ public class UnitType extends UnlockableContent implements Senseable{
             stats.add(Stat.weapons, StatValues.weapons(this, weapons));
         }
 
+        if(targetFlags.length > 0 && targetFlags[0] != null){
+            stats.add(StatExt.targets, StatValues.targets(this, targetFlags));
+        }
+
         if(immunities.size > 0){
             var imm = immunities.toSeq().sort();
             //it's redundant to list wet for naval units
@@ -690,6 +713,8 @@ public class UnitType extends UnlockableContent implements Senseable{
 
         allowLegStep = example instanceof Legsc;
 
+        stats.useCategories = true;
+
         //water preset
         if(example instanceof WaterMovec){
             naval = true;
diff --git a/core/src/mindustry/type/Weapon.java b/core/src/mindustry/type/Weapon.java
index d097677d3ca8d8b34dca7e35bc0d82cabba807fe..36ddd96f325b49b989b910ca80d0c9ee08744098 100644
--- a/core/src/mindustry/type/Weapon.java
+++ b/core/src/mindustry/type/Weapon.java
@@ -164,6 +164,18 @@ public class Weapon implements Cloneable{
     }
 
     public void addStats(UnitType u, Table t){
+        t.row();
+        t.add("[lightgray]武器范围: [stat]" + String.format("%.1f", bullet.range/8f) + " []格");
+
+        if (rotate) {
+            t.row();
+            t.add("[lightgray]旋转速度: [stat]" + String.format("%.0f", rotateSpeed * 60f) + " []°/s");
+            if (rotationLimit < 361f) {
+                t.row();
+                t.add("[lightgray]旋转范围: [stat]" + String.format("%.0f", rotationLimit) + " []" + StatUnit.degrees.localized());
+            }
+        }
+
         if(inaccuracy > 0){
             t.row();
             t.add("[lightgray]" + Stat.inaccuracy.localized() + ": [white]" + (int)inaccuracy + " " + StatUnit.degrees.localized());
diff --git a/core/src/mindustry/world/Block.java b/core/src/mindustry/world/Block.java
index 9daa65d5aaac2e74173c4c185457ff1113ab61ac..8e79e085c053b9c66d295110b2fa0ee881832e82 100644
--- a/core/src/mindustry/world/Block.java
+++ b/core/src/mindustry/world/Block.java
@@ -32,6 +32,7 @@ import mindustry.world.blocks.environment.*;
 import mindustry.world.blocks.power.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import java.lang.reflect.*;
 import java.util.*;
@@ -554,7 +555,7 @@ public class Block extends UnlockableContent implements Senseable{
             }
         }
 
-        if(canBeBuilt() && requirements.length > 0){
+        if(requirements.length > 0){
             stats.add(Stat.buildTime, buildCost / 60, StatUnit.seconds);
             stats.add(Stat.buildCost, StatValues.items(false, requirements));
         }
@@ -566,6 +567,7 @@ public class Block extends UnlockableContent implements Senseable{
         for(var c : consumers){
             c.display(stats);
         }
+        stats.add(StatExt.canOverdrive, canOverdrive);
 
         //Note: Power stats are added by the consumers.
         if(hasLiquids) stats.add(Stat.liquidCapacity, liquidCapacity, StatUnit.liquidUnits);
diff --git a/core/src/mindustry/world/blocks/defense/ForceProjector.java b/core/src/mindustry/world/blocks/defense/ForceProjector.java
index 0013d4c2ffe5c26f4aff2f9171400f46a58ff2fa..9209741524bde5648c7c9c454f5c54387b0fd410 100644
--- a/core/src/mindustry/world/blocks/defense/ForceProjector.java
+++ b/core/src/mindustry/world/blocks/defense/ForceProjector.java
@@ -22,6 +22,7 @@ import mindustry.world.*;
 import mindustry.world.blocks.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -100,13 +101,15 @@ public class ForceProjector extends Block{
 
         if(consItems) stats.timePeriod = phaseUseTime;
         super.setStats();
+        stats.add(Stat.range, radius / tilesize, StatUnit.blocks);
         stats.add(Stat.shieldHealth, shieldHealth, StatUnit.none);
         stats.add(Stat.cooldownTime, (int) (shieldHealth / cooldownBrokenBase / 60f), StatUnit.seconds);
-
+        stats.add(StatExt.regenSpeed, cooldownNormal * Time.toSeconds, StatUnit.perSecond);
+        stats.add(StatExt.regenSpeedBroken, cooldownBrokenBase * Time.toSeconds, StatUnit.perSecond);
         if(consItems && itemConsumer instanceof ConsumeItems coni){
             stats.remove(Stat.booster);
             stats.add(Stat.booster, StatValues.itemBoosters("+{0} " + StatUnit.shieldHealth.localized(), stats.timePeriod, phaseShieldBoost, phaseRadiusBoost, coni.items, this::consumesItem));
-            stats.add(Stat.booster, StatValues.speedBoosters("", coolantConsumption, Float.MAX_VALUE, true, this::consumesLiquid));
+            stats.add(Stat.booster, StatValues.speedBoosters(Core.bundle.get("shield.regenspeed"), coolantConsumption, cooldownLiquid, true, this::consumesLiquid, true));
         }
     }
 
diff --git a/core/src/mindustry/world/blocks/defense/MendProjector.java b/core/src/mindustry/world/blocks/defense/MendProjector.java
index edafc65164c72b570b779eaa6f65ab4029d946c9..b6d7155bb8ed1cc1351c9e1d07b1e1a9aabf4224 100644
--- a/core/src/mindustry/world/blocks/defense/MendProjector.java
+++ b/core/src/mindustry/world/blocks/defense/MendProjector.java
@@ -52,13 +52,15 @@ public class MendProjector extends Block{
         stats.timePeriod = useTime;
         super.setStats();
 
-        stats.add(Stat.repairTime, (int)(100f / healPercent * reload / 60f), StatUnit.seconds);
         stats.add(Stat.range, range / tilesize, StatUnit.blocks);
+        stats.add(StatExt.mend, healPercent, StatUnit.percent);
+        stats.add(StatExt.mendReload, reload / 60f, StatUnit.seconds);
+        stats.add(StatExt.mendSpeed, "@%/s", Strings.autoFixed(healPercent / (reload / 60f), 1));
 
         if(findConsumer(c -> c instanceof ConsumeItems) instanceof ConsumeItems cons){
             stats.remove(Stat.booster);
             stats.add(Stat.booster, StatValues.itemBoosters(
-                "{0}" + StatUnit.timesSpeed.localized(),
+                "{0}x修复量",
                 stats.timePeriod, (phaseBoost + healPercent) / healPercent, phaseRangeBoost,
                 cons.items, this::consumesItem)
             );
diff --git a/core/src/mindustry/world/blocks/defense/RegenProjector.java b/core/src/mindustry/world/blocks/defense/RegenProjector.java
index 69bbb61116ad4a09306c05f056020305c15ea2e2..4e446b3c30cf663542fd4d3256691a88a7cc66c7 100644
--- a/core/src/mindustry/world/blocks/defense/RegenProjector.java
+++ b/core/src/mindustry/world/blocks/defense/RegenProjector.java
@@ -14,6 +14,7 @@ import mindustry.world.*;
 import mindustry.world.consumers.*;
 import mindustry.world.draw.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -89,13 +90,13 @@ public class RegenProjector extends Block{
         stats.timePeriod = optionalUseTime;
         super.setStats();
 
-        stats.add(Stat.repairTime, (int)(1f / (healPercent / 100f) / 60f), StatUnit.seconds);
         stats.add(Stat.range, range, StatUnit.blocks);
+        stats.add(StatExt.mendSpeed, "@%/s", Strings.autoFixed(healPercent * 60f, 1));
 
         if(findConsumer(c -> c instanceof ConsumeItems) instanceof ConsumeItems cons){
             stats.remove(Stat.booster);
             stats.add(Stat.booster, StatValues.itemBoosters(
-                "{0}" + StatUnit.timesSpeed.localized(),
+                "{0}x修复速度",
                 stats.timePeriod, optionalMultiplier, 0f,
                 cons.items, this::consumesItem)
             );
diff --git a/core/src/mindustry/world/blocks/defense/ShieldWall.java b/core/src/mindustry/world/blocks/defense/ShieldWall.java
index 8f7a1135a1c2b46b7b83b8ca58cdbb12ccc90784..53c0889446bda2891a6417c435ff255953447b92 100644
--- a/core/src/mindustry/world/blocks/defense/ShieldWall.java
+++ b/core/src/mindustry/world/blocks/defense/ShieldWall.java
@@ -8,6 +8,7 @@ import arc.util.io.*;
 import mindustry.annotations.Annotations.*;
 import mindustry.graphics.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -32,6 +33,9 @@ public class ShieldWall extends Wall{
         super.setStats();
 
         stats.add(Stat.shieldHealth, shieldHealth);
+        stats.add(Stat.cooldownTime, breakCooldown / Time.toSeconds, StatUnit.seconds);
+        stats.add(StatExt.regenSpeed, regenSpeed * Time.toSeconds, StatUnit.perSecond);
+
     }
 
     public class ShieldWallBuild extends WallBuild{
diff --git a/core/src/mindustry/world/blocks/defense/turrets/PointDefenseTurret.java b/core/src/mindustry/world/blocks/defense/turrets/PointDefenseTurret.java
index 97aedf43b5595bcfb63ea9ecce91dc6e57967e92..cd30d93b35b0547658c39c0b0f6e5ef0f8300973 100644
--- a/core/src/mindustry/world/blocks/defense/turrets/PointDefenseTurret.java
+++ b/core/src/mindustry/world/blocks/defense/turrets/PointDefenseTurret.java
@@ -52,6 +52,7 @@ public class PointDefenseTurret extends ReloadTurret{
         super.setStats();
 
         stats.add(Stat.reload, 60f / reload, StatUnit.perSecond);
+        stats.add(Stat.damage, bulletDamage);
     }
 
     public class PointDefenseBuild extends ReloadTurretBuild{
diff --git a/core/src/mindustry/world/blocks/distribution/BufferedItemBridge.java b/core/src/mindustry/world/blocks/distribution/BufferedItemBridge.java
index 8a6de353e073b653abfd14a2610905705cc4e034..3a206039844a00ea43e9ac3c12e238868392b426 100644
--- a/core/src/mindustry/world/blocks/distribution/BufferedItemBridge.java
+++ b/core/src/mindustry/world/blocks/distribution/BufferedItemBridge.java
@@ -9,6 +9,7 @@ import mindustry.gen.*;
 import mindustry.graphics.*;
 import mindustry.type.*;
 import mindustry.world.*;
+import mindustry.world.meta.*;
 import mindustryX.features.*;
 
 import static mindustry.Vars.*;
@@ -26,6 +27,14 @@ public class BufferedItemBridge extends ItemBridge{
         canOverdrive = true;
     }
 
+    @Override
+    public void setStats(){
+        super.setStats();
+
+        stats.add(StatExt.bufferCapacity, bufferCapacity);
+        stats.add(Stat.itemsMoved, Strings.autoFixed(bufferCapacity * 60f / speed ,2) , StatUnit.itemsSecond);
+    }
+
     public class BufferedItemBridgeBuild extends ItemBridgeBuild{
         ItemBuffer buffer = new ItemBuffer(bufferCapacity);
 
diff --git a/core/src/mindustry/world/blocks/distribution/Junction.java b/core/src/mindustry/world/blocks/distribution/Junction.java
index a34377db8cec36032d8a27014ea9d1e79f99b0aa..e3593dbef6fc1c812a9b392de892ad0aed4c4fa6 100644
--- a/core/src/mindustry/world/blocks/distribution/Junction.java
+++ b/core/src/mindustry/world/blocks/distribution/Junction.java
@@ -30,6 +30,16 @@ public class Junction extends Block{
         noUpdateDisabled = true;
     }
 
+    @Override
+    public void setStats(){
+        super.setStats();
+
+        //have to add a custom calculated speed, since the actual movement speed is apparently not linear
+        stats.add(Stat.itemCapacity, capacity);
+        stats.add(Stat.itemsMoved,Strings.autoFixed(60f / speed * capacity ,2) , StatUnit.itemsSecond);
+    }
+
+
     @Override
     public boolean outputsItems(){
         return true;
diff --git a/core/src/mindustry/world/blocks/power/ImpactReactor.java b/core/src/mindustry/world/blocks/power/ImpactReactor.java
index 136cf66b46876bb32783bab353f1da20726410d8..528b2960a70af587b6b6fbbaf203646d0bd6a594 100644
--- a/core/src/mindustry/world/blocks/power/ImpactReactor.java
+++ b/core/src/mindustry/world/blocks/power/ImpactReactor.java
@@ -13,6 +13,7 @@ import mindustry.logic.*;
 import mindustry.ui.*;
 import mindustry.world.draw.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 public class ImpactReactor extends PowerGenerator{
     public final int timerUse = timers++;
@@ -41,6 +42,14 @@ public class ImpactReactor extends PowerGenerator{
         explodeSound = Sounds.explosionbig;
     }
 
+    private float warmupToTime(float warmup, float timeScale) {
+        return Mathf.log(1f - warmupSpeed * timeScale, 1f - warmup);
+    }
+
+    private float timeToWarmup(float time, float timeScale) {
+        return 1f - Mathf.pow(1 - warmupSpeed * timeScale, time);
+    }
+
     @Override
     public void setBars(){
         super.setBars();
@@ -59,6 +68,14 @@ public class ImpactReactor extends PowerGenerator{
         if(hasItems){
             stats.add(Stat.productionTime, itemDuration / 60f, StatUnit.seconds);
         }
+        float startTime = warmupToTime(Mathf.pow(consPower.usage / powerProduction, 1f / 5f), 1f);
+        stats.add(StatExt.warmupPartial, startTime / 60f, StatUnit.seconds);
+        stats.add(StatExt.warmupTime, warmupToTime(0.999f, 1f) / 60f, StatUnit.seconds);
+        float startConsPower = 0;
+        for (int tick = 1;tick < startTime;tick++) {
+            startConsPower += consPower.usage - Mathf.pow(timeToWarmup(tick, 1f), 5f) * powerProduction;
+        }
+        stats.add(StatExt.warmupPower, Mathf.ceil(startConsPower / 50f) * 50f, StatUnit.none);
     }
 
     public class ImpactReactorBuild extends GeneratorBuild{
diff --git a/core/src/mindustry/world/blocks/production/Drill.java b/core/src/mindustry/world/blocks/production/Drill.java
index 563d226d7400bc701b01e6408ef9d1d5f411a7e7..1c3ce617f2498facc3fe1a34c94dacbe71f8373c 100644
--- a/core/src/mindustry/world/blocks/production/Drill.java
+++ b/core/src/mindustry/world/blocks/production/Drill.java
@@ -172,10 +172,7 @@ public class Drill extends Block{
     public void setStats(){
         super.setStats();
 
-        stats.add(Stat.drillTier, StatValues.drillables(drillTime, hardnessDrillMultiplier, size * size, drillMultipliers, b -> b instanceof Floor f && !f.wallOre && f.itemDrop != null &&
-            f.itemDrop.hardness <= tier && f.itemDrop != blockedItem && (indexer.isBlockPresent(f) || state.isMenu())));
-
-        stats.add(Stat.drillSpeed, 60f / drillTime * size * size, StatUnit.itemsSecond);
+        stats.add(Stat.drillTier, StatValues.drillBlock(this));
 
         if(liquidBoostIntensity != 1 && findConsumer(f -> f instanceof ConsumeLiquidBase) instanceof ConsumeLiquidBase consBase){
             stats.remove(Stat.booster);
diff --git a/core/src/mindustry/world/blocks/sandbox/PowerSource.java b/core/src/mindustry/world/blocks/sandbox/PowerSource.java
index 0e011c9bac5573a8124e5e603f0054319eaff0ba..fa8abf6f6424f11e2155a1258157416f1e54423a 100644
--- a/core/src/mindustry/world/blocks/sandbox/PowerSource.java
+++ b/core/src/mindustry/world/blocks/sandbox/PowerSource.java
@@ -16,6 +16,12 @@ public class PowerSource extends PowerNode{
         envEnabled = Env.any;
     }
 
+    @Override
+    public void setStats() {
+        super.setStats();
+        stats.add(Stat.basePowerGeneration, powerProduction * 60f, StatUnit.powerSecond);
+    }
+
     public class PowerSourceBuild extends PowerNodeBuild{
         @Override
         public void onProximityUpdate(){
diff --git a/core/src/mindustry/world/blocks/sandbox/PowerVoid.java b/core/src/mindustry/world/blocks/sandbox/PowerVoid.java
index d0a8acf4d7438f25f5a9ec275982f6564f4a4483..6943d06cf9438d757ccc61e582fac169c20683d9 100644
--- a/core/src/mindustry/world/blocks/sandbox/PowerVoid.java
+++ b/core/src/mindustry/world/blocks/sandbox/PowerVoid.java
@@ -15,6 +15,5 @@ public class PowerVoid extends PowerBlock{
     @Override
     public void setStats(){
         super.setStats();
-        stats.remove(Stat.powerUse);
     }
 }
diff --git a/core/src/mindustry/world/consumers/ConsumeItemDynamic.java b/core/src/mindustry/world/consumers/ConsumeItemDynamic.java
index b026ce3df9bf727ee389d951697f55e8ab107e25..18a1275dee82959a029866c6013346e3e2f976ed 100644
--- a/core/src/mindustry/world/consumers/ConsumeItemDynamic.java
+++ b/core/src/mindustry/world/consumers/ConsumeItemDynamic.java
@@ -43,7 +43,7 @@ public class ConsumeItemDynamic extends Consume{
         int i = 0;
 
         for(ItemStack stack : items.get(build)){
-            table.add(new ReqImage(StatValues.stack(stack.item, Math.round(stack.amount * multiplier.get(build))),
+            table.add(new ReqImage(StatValues.stack(stack.item, Math.round(stack.amount * multiplier.get(build)), () -> build.items.get(stack.item)),
             () -> build.items != null && build.items.has(stack.item, Math.round(stack.amount * multiplier.get(build))))).padRight(8).left();
             if(++i % 4 == 0) table.row();
         }
diff --git a/core/src/mindustry/world/consumers/ConsumeItems.java b/core/src/mindustry/world/consumers/ConsumeItems.java
index c43fa42a320a88864ca8d73b88504a8c31fa1739..92d2d1465df74bf84f3a5d39e38c4dbb2795c112 100644
--- a/core/src/mindustry/world/consumers/ConsumeItems.java
+++ b/core/src/mindustry/world/consumers/ConsumeItems.java
@@ -33,7 +33,7 @@ public class ConsumeItems extends Consume{
         table.table(c -> {
             int i = 0;
             for(var stack : items){
-                c.add(new ReqImage(StatValues.stack(stack.item, Math.round(stack.amount * multiplier.get(build))),
+                c.add(new ReqImage(StatValues.stack(stack.item, Math.round(stack.amount * multiplier.get(build)), () -> build.items.get(stack.item)),
                 () -> build.items.has(stack.item, Math.round(stack.amount * multiplier.get(build))))).padRight(8);
                 if(++i % 4 == 0) c.row();
             }
diff --git a/core/src/mindustry/world/consumers/ConsumePayloadDynamic.java b/core/src/mindustry/world/consumers/ConsumePayloadDynamic.java
index ebb6f324301c123e852285150b9467f59f35d414..e038f3ee493377f161843a6a469e75f82c7806b8 100644
--- a/core/src/mindustry/world/consumers/ConsumePayloadDynamic.java
+++ b/core/src/mindustry/world/consumers/ConsumePayloadDynamic.java
@@ -63,7 +63,7 @@ public class ConsumePayloadDynamic extends Consume{
         table.table(c -> {
             int i = 0;
             for(var stack : pay){
-                c.add(new ReqImage(StatValues.stack(stack.item, Math.round(stack.amount * multiplier.get(build))),
+                c.add(new ReqImage(StatValues.stack(stack.item, Math.round(stack.amount * multiplier.get(build)), () -> build.getPayloads().get(stack.item)),
                 () -> inv.contains(stack.item, Math.round(stack.amount * multiplier.get(build))))).padRight(8);
                 if(++i % 4 == 0) c.row();
             }
diff --git a/core/src/mindustry/world/meta/Stat.java b/core/src/mindustry/world/meta/Stat.java
index b1257d6232977ca6baaa841b0483fe3d3d1f5871..4249bb2ca961dfbc20fa38fe5b1cc8f079bbc554 100644
--- a/core/src/mindustry/world/meta/Stat.java
+++ b/core/src/mindustry/world/meta/Stat.java
@@ -25,17 +25,18 @@ public class Stat implements Comparable<Stat>{
     heatCapacity = new Stat("heatCapacity"),
     viscosity = new Stat("viscosity"),
     temperature = new Stat("temperature"),
-    flying = new Stat("flying"),
-    speed = new Stat("speed"),
-    buildSpeed = new Stat("buildSpeed"),
-    mineSpeed = new Stat("mineSpeed"),
-    mineTier = new Stat("mineTier"),
-    payloadCapacity = new Stat("payloadCapacity"),
+    flying = new Stat("flying", StatCat.movement),
+    speed = new Stat("speed", StatCat.movement),
+    buildSpeed = new Stat("buildSpeed", StatCat.support),
+    mineSpeed = new Stat("mineSpeed", StatCat.support),
+    mineTier = new Stat("mineTier", StatCat.support),
+    payloadCapacity = new Stat("payloadCapacity", StatCat.support),
+
     baseDeflectChance = new Stat("baseDeflectChance"),
     lightningChance = new Stat("lightningChance"),
     lightningDamage = new Stat("lightningDamage"),
-    abilities = new Stat("abilities"),
-    canBoost = new Stat("canBoost"),
+    abilities = new Stat("abilities", StatCat.combat),
+    canBoost = new Stat("canBoost", StatCat.movement),
     maxUnits = new Stat("maxUnits"),
 
     damageMultiplier = new Stat("damageMultiplier"),
@@ -71,8 +72,8 @@ public class Stat implements Comparable<Stat>{
     linkRange = new Stat("linkRange", StatCat.crafting),
     instructions = new Stat("instructions", StatCat.crafting),
 
-    weapons = new Stat("weapons", StatCat.function),
-    bullet = new Stat("bullet", StatCat.function),
+    weapons = new Stat("weapons", StatCat.combat),
+    bullet = new Stat("bullet", StatCat.combat),
 
     speedIncrease = new Stat("speedIncrease", StatCat.function),
     repairTime = new Stat("repairTime", StatCat.function),
diff --git a/core/src/mindustry/world/meta/StatCat.java b/core/src/mindustry/world/meta/StatCat.java
index 416df5a20af4767cdfdc2646bce19468ad11cd28..239311eea91980f2c3e0facd6613b2373cc11909 100644
--- a/core/src/mindustry/world/meta/StatCat.java
+++ b/core/src/mindustry/world/meta/StatCat.java
@@ -15,7 +15,10 @@ public class StatCat implements Comparable<StatCat>{
     items = new StatCat("items"),
     crafting = new StatCat("crafting"),
     function = new StatCat("function"),
-    optional = new StatCat("optional");
+    optional = new StatCat("optional"),
+    support =  new StatCat("support"),
+    combat =  new StatCat("combat"),
+    movement =  new StatCat("movement");
 
     public final String name;
     public final int id;
diff --git a/core/src/mindustry/world/meta/StatValues.java b/core/src/mindustry/world/meta/StatValues.java
index e05c129ea3de18c95f74e731b0f01fdfdb508040..dcaad1248422b9e3ab62d5ffb28bc76cea00a558 100644
--- a/core/src/mindustry/world/meta/StatValues.java
+++ b/core/src/mindustry/world/meta/StatValues.java
@@ -16,7 +16,7 @@ import mindustry.*;
 import mindustry.content.*;
 import mindustry.core.*;
 import mindustry.ctype.*;
-import mindustry.entities.abilities.*;
+import mindustry.entities.abilities.Ability;
 import mindustry.entities.bullet.*;
 import mindustry.gen.*;
 import mindustry.maps.*;
@@ -25,6 +25,9 @@ import mindustry.ui.*;
 import mindustry.world.*;
 import mindustry.world.blocks.defense.turrets.*;
 import mindustry.world.blocks.environment.*;
+import mindustry.world.blocks.production.Drill;
+import mindustryX.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -217,6 +220,17 @@ public class StatValues{
         return stack(item.uiIcon, amount, item);
     }
 
+    @MindustryXApi
+    public static Stack stack(UnlockableContent item, int amount, Intp curAmount){
+        Stack stack = stack(item.uiIcon, amount, item);
+        stack.add(new Table(t -> {
+            t.left().top();
+            t.label(() -> String.valueOf(curAmount.get())).get().setFontScale(0.6f);
+            t.pack();
+        }));
+        return stack;
+    }
+
     public static Stack stack(UnlockableContent item, int amount, boolean tooltip){
         return stack(item.uiIcon, amount, item, tooltip);
     }
@@ -289,7 +303,7 @@ public class StatValues{
 
                 if(state.isGame()){
                     var blocks = Vars.content.blocks()
-                    .select(block -> (!checkFloors || block instanceof Floor) && indexer.isBlockPresent(block) && block.attributes.get(attr) != 0 && !((block instanceof Floor f && f.isDeep()) && !floating))
+                    .select(block -> (!checkFloors || block instanceof Floor) && block.attributes.get(attr) != 0 && !((block instanceof Floor f && f.isDeep()) && !floating))
                     .with(s -> s.sort(f -> f.attributes.get(attr)));
 
                     if(blocks.any()){
@@ -362,7 +376,39 @@ public class StatValues{
         return content(list.as());
     }
 
-    public static StatValue drillables(float drillTime, float drillMultiplier, float size, ObjectFloatMap<Item> multipliers, Boolf<Block> filter){
+    public static StatValue drillBlock(Drill drill){
+        Seq<Block> list = content.blocks().select(b -> b instanceof Floor f && !f.wallOre && f.itemDrop != null && f.itemDrop.hardness <= drill.tier && f.itemDrop != drill.blockedItem);
+        list.sort(t -> drill.getDrillTime(t.itemDrop));
+        return table -> {
+            table.row();
+            table.table(at -> {
+                at.background(Styles.grayPanel);
+                at.add("[stat]" + drill.tier + "[lightgray]级[accent] ~ [stat]" +
+                Strings.autoFixed(60f / drill.drillTime * drill.size * drill.size, 2) + "[lightgray]物品/s");
+                at.row();
+                if(list.size == 0) return;
+                at.table(t -> {
+                    float[] eff = new float[list.size];
+                    for(int i = 0; i < list.size; i++){
+                        eff[i] = 60f / drill.getDrillTime(list.get(i).itemDrop) * drill.size * drill.size;
+                    }
+                    StringBuilder oreList = new StringBuilder();
+                    for(int i = 0; i < list.size; i++){
+                        Block block = list.get(i);
+                        oreList.append(block.emoji()).append(" ").append(block.localizedName);
+                        if(i == list.size - 1 || eff[i] != eff[i + 1]){
+                            t.labelWrap(oreList.toString()).width(250f).padLeft(20f).padTop(5f);
+                            t.add("[stat]" + Strings.fixed(eff[i], 2)).padLeft(20f);
+                            t.add("[cyan]" + Strings.fixed(eff[i] * drill.liquidBoostIntensity * drill.liquidBoostIntensity, 2)).padLeft(20f).padRight(20f);
+                            t.row();
+                            oreList = new StringBuilder();
+                        }else oreList.append("  ");
+                    }
+                });
+            });
+        };
+    }
+    public static StatValue drillables(float drillTime, float hardnessMultiplier, float size, ObjectFloatMap<Item> multipliers, Boolf<Block> filter){
         return table -> {
             table.row();
             table.table(c -> {
@@ -377,10 +423,8 @@ public class StatValues{
                             info.add(block.localizedName).left().row();
                             info.add(block.itemDrop.emoji()).with(l -> withTooltip(l, block.itemDrop)).left();
                         }).grow();
-                        if(multipliers != null){
-                            b.add(Strings.autoFixed(60f / (Math.max(drillTime + drillMultiplier * block.itemDrop.hardness, drillTime) / multipliers.get(block.itemDrop, 1f)) * size, 2) + StatUnit.perSecond.localized())
-                            .right().pad(10f).padRight(15f).color(Color.lightGray);
-                        }
+                        b.add(Strings.autoFixed(60f / (drillTime + hardnessMultiplier * block.itemDrop.hardness) * (multipliers == null ? 1 : multipliers.get(block.itemDrop, 1f)) * size, 2) + StatUnit.perSecond.localized())
+                        .right().pad(10f).padRight(15f).color(Color.lightGray);
                     }).growX().pad(5);
                     if(++i % 2 == 0) c.row();
                 }
@@ -418,6 +462,10 @@ public class StatValues{
     }
 
     public static StatValue speedBoosters(String unit, float amount, float speed, boolean strength, Boolf<Liquid> filter){
+        return speedBoosters(unit, amount, speed, strength, filter, false);
+    }
+
+    public static StatValue speedBoosters(String unit, float amount, float speed, boolean strength, Boolf<Liquid> filter, Boolean isForce){
         return table -> {
             table.row();
             table.table(c -> {
@@ -433,7 +481,8 @@ public class StatValues{
 
                         b.table(bt -> {
                             bt.right().defaults().padRight(3).left();
-                            if(speed != Float.MAX_VALUE) bt.add(unit.replace("{0}", "[stat]" + Strings.autoFixed(speed * (strength ? liquid.heatCapacity : 1f) + (strength ? 1f : 0f), 2) + "[lightgray]")).pad(5);
+                            if(isForce) bt.add(unit.replace("{0}", "[stat]" + Strings.autoFixed(speed * ((liquid.heatCapacity - 0.4f) * 0.9f + 1), 2) + "[lightgray]")).pad(5);
+                            else if(speed != Float.MAX_VALUE) bt.add(unit.replace("{0}", "[stat]" + Strings.autoFixed(speed * (strength ? liquid.heatCapacity : 1f) + (strength ? 1f : 0f), 2) + "[lightgray]")).pad(5);
                         }).right().grow().pad(10f).padRight(15f);
                     }).growX().pad(5).row();
                 }
@@ -496,26 +545,54 @@ public class StatValues{
         };
     }
 
+    @MindustryXApi.Keep
     public static StatValue abilities(Seq<Ability> abilities){
+        return abilities(null, abilities);
+    }
+
+    @MindustryXApi
+    public static StatValue abilities(@Nullable UnitType unit, Seq<Ability> abilities){
+        return table -> {
+            table.row();
+            table.table(t -> abilities.each(ability -> {
+                if(ability.display){
+                    t.row();
+                    t.table(Styles.grayPanel, a -> {
+                        a.left().top().defaults().left();
+                        a.add("[accent]" + ability.localized()).minWidth(100).padBottom(4);
+                        var customDescription = unit == null ? null : StatExt.description(ability, unit);
+                        if(customDescription != null){
+                            a.add(customDescription).row();
+                        }
+                        a.defaults().colspan(2);
+                        ability.addStats(a);
+                    }).pad(5).margin(10).growX();
+                }
+            }));
+        };
+    }
+
+    public static StatValue targets(UnitType unit, BlockFlag[] targetFlags){
         return table -> {
             table.row();
             table.table(t -> {
-                int count = 0;
-                for(Ability ability : abilities){
-                    if(ability.display){
-                        t.table(Styles.grayPanel, a -> {
-                            a.add("[accent]" + ability.localized()).padBottom(4).center().top().expandX();
-                            a.row();
-                            a.left().top().defaults().left();
-                            ability.addStats(a);
-                        }).pad(5).margin(10).growX().top().uniformX();
-                        if((++count) == 2){
-                            count = 0;
-                            t.row();
+                t.background(Styles.grayPanel);
+                for(BlockFlag flag : targetFlags){
+                    if(flag == null) continue;
+                    t.add(flag.name()).width(150f).padBottom(5f);
+                    int count = 0;
+                    for(Block block : content.blocks()){
+                        if(block.flags.contains(flag)){
+                            if(count >= 3){
+                                t.add("\uE813").width(30f);
+                                break;
+                            }else t.add(block.emoji()).width(30f);
+                            count += 1;
                         }
                     }
-                };
-            });
+                    t.row();
+                }
+            }).padLeft(12f);
         };
     }
 
@@ -556,7 +633,9 @@ public class StatValues{
                         bt.row();
                     }
 
-                    if(type.damage > 0 && (type.collides || type.splashDamage <= 0)){
+                    if(type instanceof LightningBulletType lb){
+                        lightning(0, lb.damage, lb.lightningLength, lb.lightningLengthRand).display(bt);
+                    }else if(type.damage > 0 && (type.collides || type.splashDamage <= 0)){
                         if(type.continuousDamage() > 0){
                             bt.add(Core.bundle.format("bullet.damage", type.continuousDamage()) + StatUnit.perSecond.localized());
                         }else{
@@ -565,12 +644,11 @@ public class StatValues{
                     }
 
                     if(type.buildingDamageMultiplier != 1){
-                        int val = (int)(type.buildingDamageMultiplier * 100 - 100);
-                        sep(bt, Core.bundle.format("bullet.buildingdamage", ammoStat(val)));
+                        sep(bt, colorize(type.buildingDamageMultiplier) + "[lightgray]x建筑伤害");
                     }
 
                     if(type.rangeChange != 0 && !compact){
-                        sep(bt, Core.bundle.format("bullet.range", ammoStat(type.rangeChange / tilesize)));
+                        sep(bt, "[lightgray]射程 + " + colorize(type.rangeChange / tilesize > 0) + Strings.autoFixed(type.rangeChange / tilesize, 1) + " [lightgray]格");
                     }
 
                     if(type.splashDamage > 0){
@@ -582,8 +660,7 @@ public class StatValues{
                     }
 
                     if(!compact && !Mathf.equal(type.reloadMultiplier, 1f)){
-                        int val = (int)(type.reloadMultiplier * 100 - 100);
-                        sep(bt, Core.bundle.format("bullet.reload", ammoStat(val)));
+                        sep(bt, colorize(type.reloadMultiplier) + "[lightgray]x射速");
                     }
 
                     if(type.knockback > 0){
@@ -598,8 +675,24 @@ public class StatValues{
                         sep(bt, Core.bundle.format("bullet.healamount", Strings.autoFixed(type.healAmount, 2)));
                     }
 
-                    if(type.pierce || type.pierceCap != -1){
-                        sep(bt, type.pierceCap == -1 ? "@bullet.infinitepierce" : Core.bundle.format("bullet.pierce", type.pierceCap));
+                    if((type.pierce || type.pierceCap != -1) && !(type instanceof PointLaserBulletType)){
+                        boolean laserPierce = type instanceof LaserBulletType || type instanceof ContinuousLaserBulletType || type instanceof ShrapnelBulletType;
+                        boolean pierceBuilding = laserPierce || type instanceof ContinuousFlameBulletType || type instanceof RailBulletType || type.pierceBuilding;
+                        boolean pierceUnit = type.pierce;
+                        StringBuilder str = new StringBuilder("[stat]");
+                        if(type instanceof RailBulletType rail){
+                            str.append(Strings.autoFixed(rail.pierceDamageFactor * 100f, 1) + "%衰减");
+                        }else{
+                            str.append(type.pierceCap == -1 ? "无限" : type.pierceCap + "x");
+                        }
+                        str.append("穿透[lightgray]");
+                        if(pierceBuilding && pierceUnit){
+                            str.append("建筑与单位");
+                        }else{
+                            str.append(pierceBuilding ? "建筑" : "单位");
+                        }
+                        if(laserPierce) str.append("[stat](电性)");
+                        sep(bt, str.toString());
                     }
 
                     if(type.incendAmount > 0){
@@ -607,11 +700,11 @@ public class StatValues{
                     }
 
                     if(type.homingPower > 0.01f){
-                        sep(bt, "@bullet.homing");
+                        sep(bt, "[stat]追踪[lightgray]~[]" + Strings.autoFixed(type.homingPower * 50 * Time.toSeconds, 1) + "°/s[lightgray]~[]" + Strings.fixed(type.homingRange / tilesize, 1) + "[lightgray]格");
                     }
 
-                    if(type.lightning > 0){
-                        sep(bt, Core.bundle.format("bullet.lightning", type.lightning, type.lightningDamage < 0 ? type.damage : type.lightningDamage));
+                    if(!(type instanceof LightningBulletType) && type.lightning > 0){
+                        lightning(type.lightning, type.lightningDamage < 0 ? type.damage : type.lightningDamage, type.lightningLength, type.lightningLengthRand).display(bt);
                     }
 
                     if(type.pierceArmor){
@@ -619,7 +712,7 @@ public class StatValues{
                     }
 
                     if(type.maxDamageFraction > 0){
-                        sep(bt, Core.bundle.format("bullet.maxdamagefraction", (int)(type.maxDamageFraction * 100))); 
+                        sep(bt, Core.bundle.format("bullet.maxdamagefraction", (int)(type.maxDamageFraction * 100)));
                     }
 
                     if(type.suppressionRange > 0){
@@ -645,26 +738,54 @@ public class StatValues{
                             it.add(Core.bundle.format("bullet.interval", Strings.autoFixed(type.intervalBullets / type.bulletInterval * 60, 2)));
                             it.button(Icon.downOpen, Styles.emptyi, () -> coll.toggle(false)).update(i -> i.getStyle().imageUp = (!coll.isCollapsed() ? Icon.upOpen : Icon.downOpen)).size(8).padLeft(16f).expandX();
                         });
-                        bt.row();
-                        bt.add(coll);
                     }
 
-                    if(type.fragBullet != null){
-                        bt.row();
+                    if(type instanceof EmpBulletType eb){
+                        collapse(bt, Strings.format("[stat]EMP~@[lightgray]格[]~[white]\uE810[]@%/[white]\uE86D[]@%~[white]\uF899[][green]@%[]/[negstat]@%[]",
+                        Strings.autoFixed(eb.radius / tilesize, 0),
+                        Strings.autoFixed(eb.powerDamageScl * 100, 0),
+                        Strings.autoFixed(eb.unitDamageScl * 100, 0),
+                        Strings.autoFixed(eb.timeIncrease * 100, 0),
+                        Strings.autoFixed(eb.powerSclDecrease * 100, 0)
+                        ), ec -> {
+                            ec.defaults().padLeft(5f);
+                            sep(ec, Strings.format("[stat]对敌方电网建筑造成@%子弹伤害", Strings.autoFixed(eb.powerDamageScl * 100, 0)));
+                            sep(ec, Strings.format("[stat]对敌方单位造成@%子弹伤害", Strings.autoFixed(eb.unitDamageScl * 100, 0)));
+                            sep(ec, Strings.format("[stat]对我方耗电建筑超速至@%", Strings.autoFixed(eb.timeIncrease * 100, 0)));
+                            sep(ec, Strings.format("[stat]对敌方电网建筑减速至@%", Strings.autoFixed(eb.powerSclDecrease * 100, 0)));
+                        });
+                    }
 
-                        Table fc = new Table();
-                        ammo(ObjectMap.of(t, type.fragBullet), indent + 1, false).display(fc);
-                        Collapser coll = new Collapser(fc, true);
-                        coll.setDuration(0.1f);
+                    if(type.fragBullet != null){
+                        collapse(bt, Core.bundle.format("bullet.frags", type.fragBullets), fc -> {
+                            ammo(ObjectMap.of(t, type.fragBullet), indent + 1, false).display(fc);
+                        });
+                    }
 
-                        bt.table(ft -> {
-                            ft.left().defaults().left();
+                    if(type.intervalBullet != null){
+                        collapse(bt, Core.bundle.format("bullet.interval", Strings.autoFixed(type.intervalBullets / type.bulletInterval * 60, 2)), ic -> {
+                            ammo(ObjectMap.of(t, type.intervalBullet), indent + 1, false).display(ic);
+                        });
+                    }
 
-                            ft.add(Core.bundle.format("bullet.frags", type.fragBullets));
-                            ft.button(Icon.downOpen, Styles.emptyi, () -> coll.toggle(false)).update(i -> i.getStyle().imageUp = (!coll.isCollapsed() ? Icon.upOpen : Icon.downOpen)).size(8).padLeft(16f).expandX();
+                    Seq<BulletType> spawn = type.spawnBullets.copy();
+                    if(spawn.any()){
+                        collapse(bt, Strings.format("[stat]@x[lightgray]生成子弹：", spawn.size), sc -> {
+                            while(spawn.any()){
+                                BulletType bullet = spawn.first();
+                                Boolf<BulletType> pred = b -> bullet.damage == b.damage && bullet.splashDamage == b.splashDamage;
+                                //通过pred的的子弹被认为和当前子弹是一样的，合并显示
+                                int count = spawn.count(pred);
+                                if(count == type.spawnBullets.size){
+                                    ammo(ObjectMap.of(t, bullet), indent + 1, false).display(sc);
+                                }else{
+                                    sep(sc, Strings.format(" [stat]@x[lightgray]子弹：", count)).padLeft(0f);//不知道为什么padLeft0刚刚好，就这样了
+                                    ammo(ObjectMap.of(t, bullet), indent + 2, false).display(sc);
+                                }
+                                bt.row();
+                                spawn.removeAll(pred);
+                            }
                         });
-                        bt.row();
-                        bt.add(coll);
                     }
                 }).padLeft(indent * 5).padTop(5).padBottom(compact ? 0 : 5).growX().margin(compact ? 0 : 10);
                 table.row();
@@ -672,17 +793,61 @@ public class StatValues{
         };
     }
 
+    public static StatValue lightning(int shots, float damage, int length, int lengthRand){
+        return table -> {
+            String str = "[lightgray]";
+            if(shots > 0){
+                str += String.format("[stat]%d[]x", shots);
+            }
+            str += String.format("闪电~[stat]%s[]伤害~", Strings.autoFixed(damage, 1));
+            if(lengthRand > 0){
+                str += String.format("[stat]%d~%d[]长度", length, length + lengthRand);
+            }else{
+                str += String.format("[stat]%d[]长度", length);
+            }
+            sep(table, str);
+        };
+    }
+
     //for AmmoListValue
     private static Cell<?> sep(Table table, String text){
         table.row();
         return table.add(text);
     }
 
+    private static void collapse(Table table, String text, Cons<Table> cons){
+        table.row();
+
+        Table collt = new Table();
+        collt.left().defaults().left();
+        cons.get(collt);
+
+        Collapser coll = new Collapser(collt, true);
+        coll.setDuration(0.1f);
+
+        table.table(tt -> {
+            tt.add(text);
+            tt.button(Icon.downOpen, Styles.emptyi, () -> coll.toggle(false))
+            .update(i -> i.getStyle().imageUp = (!coll.isCollapsed() ? Icon.upOpen : Icon.downOpen))
+            .size(8).padLeft(16f).expandX();
+        });
+        table.row();
+        table.add(coll);
+    }
+
     //for AmmoListValue
     private static String ammoStat(float val){
         return (val > 0 ? "[stat]+" : "[negstat]") + Strings.autoFixed(val, 1);
     }
 
+    private static String colorize(float val){
+        return (val > 1 ? "[stat]" : "[negstat]") + Strings.autoFixed(val, 2);
+    }
+
+    private static String colorize(boolean val){
+        return val ? "[stat]" : "[negstat]";
+    }
+
     private static TextureRegion icon(UnlockableContent t){
         return t.uiIcon;
     }
