From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: way-zer <himc.wicp@gmail.com>
Date: Sun, 18 Feb 2024 03:08:37 +0800
Subject: [PATCH] HC: StatExt
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

修复一些显示错误
way-zer <himc.wicp@gmail.com> on 2024/5/4 at 22:17
---
 core/src/mindustry/type/Item.java             |   5 +
 core/src/mindustry/type/Liquid.java           |   2 +
 core/src/mindustry/type/StatusEffect.java     |   2 +
 core/src/mindustry/type/UnitType.java         |  37 +++-
 core/src/mindustry/type/Weapon.java           |  12 ++
 core/src/mindustry/world/Block.java           |   4 +-
 .../world/blocks/defense/ForceProjector.java  |   5 +-
 .../world/blocks/defense/MendProjector.java   |   6 +-
 .../world/blocks/defense/RegenProjector.java  |   5 +-
 .../world/blocks/defense/ShieldWall.java      |   4 +
 .../defense/turrets/PointDefenseTurret.java   |   1 +
 .../distribution/BufferedItemBridge.java      |   9 +
 .../world/blocks/distribution/Junction.java   |  10 +
 .../world/blocks/power/ImpactReactor.java     |  17 ++
 .../world/blocks/sandbox/PowerSource.java     |   6 +
 .../world/blocks/sandbox/PowerVoid.java       |   1 -
 .../world/consumers/ConsumeItemDynamic.java   |   2 +-
 .../world/consumers/ConsumeItems.java         |   2 +-
 .../consumers/ConsumePayloadDynamic.java      |   2 +-
 core/src/mindustry/world/meta/Stat.java       |  21 +-
 core/src/mindustry/world/meta/StatCat.java    |   5 +-
 core/src/mindustry/world/meta/StatValues.java | 201 ++++++++++++++----
 22 files changed, 286 insertions(+), 73 deletions(-)

diff --git a/core/src/mindustry/type/Item.java b/core/src/mindustry/type/Item.java
index 5d81790919f016776eff80c6d241b1d034f76d11..ff81bc3b9d0a54e7aa0e8dae9e12d48612a9d2ab 100644
--- a/core/src/mindustry/type/Item.java
+++ b/core/src/mindustry/type/Item.java
@@ -12,6 +12,7 @@ import mindustry.graphics.MultiPacker.*;
 import mindustry.logic.*;
 import mindustry.world.blocks.environment.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -112,6 +113,10 @@ public class Item extends UnlockableContent implements Senseable{
         stats.addPercent(Stat.flammability, flammability);
         stats.addPercent(Stat.radioactivity, radioactivity);
         stats.addPercent(Stat.charge, charge);
+        stats.add(StatExt.cost, cost);
+        stats.add(StatExt.hardness, hardness);
+        stats.add(StatExt.healthScaling,healthScaling);
+        stats.add(StatExt.buildable,buildable);
     }
 
     @Override
diff --git a/core/src/mindustry/type/Liquid.java b/core/src/mindustry/type/Liquid.java
index 9032b4bf9bdcacd31826eb95fedc7781465cc87a..ccb3c4b63be9aebc1c66f1003e4b17f10db1a2d7 100644
--- a/core/src/mindustry/type/Liquid.java
+++ b/core/src/mindustry/type/Liquid.java
@@ -13,6 +13,7 @@ import mindustry.graphics.*;
 import mindustry.logic.*;
 import mindustry.world.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.entities.Puddles.*;
 
@@ -165,6 +166,7 @@ public class Liquid extends UnlockableContent implements Senseable{
         stats.addPercent(Stat.temperature, temperature);
         stats.addPercent(Stat.heatCapacity, heatCapacity);
         stats.addPercent(Stat.viscosity, viscosity);
+        stats.add(StatExt.boilPoint,boilPoint);
     }
 
     @Override
diff --git a/core/src/mindustry/type/StatusEffect.java b/core/src/mindustry/type/StatusEffect.java
index 05dc34595d11d67a878c5dbaef8340fe6becf3ce..423eece86780e56801cae15e5870bc258493366a 100644
--- a/core/src/mindustry/type/StatusEffect.java
+++ b/core/src/mindustry/type/StatusEffect.java
@@ -13,6 +13,7 @@ import mindustry.gen.*;
 import mindustry.graphics.*;
 import mindustry.graphics.MultiPacker.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 public class StatusEffect extends UnlockableContent{
     /** Damage dealt by the unit with the effect. */
@@ -95,6 +96,7 @@ public class StatusEffect extends UnlockableContent{
         if(speedMultiplier != 1) stats.addMultModifier(Stat.speedMultiplier, speedMultiplier);
         if(reloadMultiplier != 1) stats.addMultModifier(Stat.reloadMultiplier, reloadMultiplier);
         if(buildSpeedMultiplier != 1) stats.addMultModifier(Stat.buildSpeedMultiplier, buildSpeedMultiplier);
+        if(dragMultiplier != 1) stats.addMultModifier(StatExt.dragMultiplier, dragMultiplier);
         if(damage > 0) stats.add(Stat.damage, damage * 60f, StatUnit.perSecond);
         if(damage < 0) stats.add(Stat.healing, -damage * 60f, StatUnit.perSecond);
 
diff --git a/core/src/mindustry/type/UnitType.java b/core/src/mindustry/type/UnitType.java
index a8d7ddc846ddac7b0960bf55d93dbf76de712d70..66a322af712862276a5ad407bd6ff5c942ee42c0 100644
--- a/core/src/mindustry/type/UnitType.java
+++ b/core/src/mindustry/type/UnitType.java
@@ -37,6 +37,7 @@ import mindustry.world.blocks.payloads.*;
 import mindustry.world.blocks.units.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static arc.graphics.g2d.Draw.*;
 import static mindustry.Vars.*;
@@ -625,29 +626,47 @@ public class UnitType extends UnlockableContent implements Senseable{
         stats.add(Stat.health, health);
         stats.add(Stat.armor, armor);
         stats.add(Stat.speed, speed * 60f / tilesize, StatUnit.tilesSecond);
+        stats.add(StatExt.rotateSpeed, rotateSpeed);
         stats.add(Stat.size, StatValues.squared(hitSize / tilesize, StatUnit.blocks));
         stats.add(Stat.itemCapacity, itemCapacity);
         stats.add(Stat.range, (int)(maxRange / tilesize), StatUnit.blocks);
         stats.add(Stat.targetsAir, targetAir);
         stats.add(Stat.targetsGround, targetGround);
+        stats.add(StatExt.unitItemCapacity, itemCapacity);
+        stats.add(StatExt.aiController,aiController.get().getClass().getSimpleName());
 
         if(abilities.any()){
-            stats.add(Stat.abilities, StatValues.abilities(abilities));
+            stats.add(Stat.abilities, StatValues.abilities(this, abilities));
+        }
+
+        stats.add(StatExt.unitrange, (int)(maxRange / tilesize), StatUnit.blocks);
+        stats.add(StatExt.estimateDPS,estimateDps());
+        stats.add(StatExt.ammoType, ammoType.icon());
+        stats.add(StatExt.ammoCapacity, ammoCapacity);
+        if (crushDamage > 0) {
+            stats.add(StatExt.crushDamage, crushDamage * 60f, StatUnit.perSecond);
         }
 
         stats.add(Stat.flying, flying);
 
         if(!flying){
             stats.add(Stat.canBoost, canBoost);
+            if(canBoost && boostMultiplier != 1){
+                stats.add(StatExt.boostMultiplier, boostMultiplier);
+            }
+        }
+        if(drownTimeMultiplier != 1){
+            stats.add(StatExt.drownTimeMultiplier, drownTimeMultiplier);
         }
 
         if(mineTier >= 1){
+            stats.add(StatExt.mineLevel, "@级", mineTier);
             stats.addPercent(Stat.mineSpeed, mineSpeed);
-            stats.add(Stat.mineTier, StatValues.drillables(mineSpeed, 1f, 1, null, b ->
-                b.itemDrop != null &&
-                (b instanceof Floor f && (((f.wallOre && mineWalls) || (!f.wallOre && mineFloor))) ||
-                (!(b instanceof Floor) && mineWalls)) &&
-                b.itemDrop.hardness <= mineTier && (!b.playerUnmineable || Core.settings.getBool("doubletapmine"))));
+            stats.add(Stat.mineTier, StatValues.drillables(mineHardnessScaling ? 50 : 65, mineHardnessScaling ? 1 : 0, mineSpeed, null, b ->
+            b.itemDrop != null &&
+            (b instanceof Floor f && (((f.wallOre && mineWalls) || (!f.wallOre && mineFloor))) ||
+            (!(b instanceof Floor) && mineWalls)) &&
+            b.itemDrop.hardness <= mineTier && (!b.playerUnmineable || Core.settings.getBool("doubletapmine"))));
         }
         if(buildSpeed > 0){
             stats.addPercent(Stat.buildSpeed, buildSpeed);
@@ -666,6 +685,10 @@ public class UnitType extends UnlockableContent implements Senseable{
             stats.add(Stat.weapons, StatValues.weapons(this, weapons));
         }
 
+        if(targetFlags.length > 0 && targetFlags[0] != null){
+            stats.add(StatExt.targets, StatValues.targets(targetFlags));
+        }
+
         if(immunities.size > 0){
             var imm = immunities.toSeq().sort();
             //it's redundant to list wet for naval units
@@ -697,6 +720,8 @@ public class UnitType extends UnlockableContent implements Senseable{
 
         allowLegStep = example instanceof Legsc;
 
+        stats.useCategories = true;
+
         //water preset
         if(example instanceof WaterMovec){
             naval = true;
diff --git a/core/src/mindustry/type/Weapon.java b/core/src/mindustry/type/Weapon.java
index d097677d3ca8d8b34dca7e35bc0d82cabba807fe..36ddd96f325b49b989b910ca80d0c9ee08744098 100644
--- a/core/src/mindustry/type/Weapon.java
+++ b/core/src/mindustry/type/Weapon.java
@@ -164,6 +164,18 @@ public class Weapon implements Cloneable{
     }
 
     public void addStats(UnitType u, Table t){
+        t.row();
+        t.add("[lightgray]武器范围: [stat]" + String.format("%.1f", bullet.range/8f) + " []格");
+
+        if (rotate) {
+            t.row();
+            t.add("[lightgray]旋转速度: [stat]" + String.format("%.0f", rotateSpeed * 60f) + " []°/s");
+            if (rotationLimit < 361f) {
+                t.row();
+                t.add("[lightgray]旋转范围: [stat]" + String.format("%.0f", rotationLimit) + " []" + StatUnit.degrees.localized());
+            }
+        }
+
         if(inaccuracy > 0){
             t.row();
             t.add("[lightgray]" + Stat.inaccuracy.localized() + ": [white]" + (int)inaccuracy + " " + StatUnit.degrees.localized());
diff --git a/core/src/mindustry/world/Block.java b/core/src/mindustry/world/Block.java
index 9daa65d5aaac2e74173c4c185457ff1113ab61ac..8e79e085c053b9c66d295110b2fa0ee881832e82 100644
--- a/core/src/mindustry/world/Block.java
+++ b/core/src/mindustry/world/Block.java
@@ -32,6 +32,7 @@ import mindustry.world.blocks.environment.*;
 import mindustry.world.blocks.power.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import java.lang.reflect.*;
 import java.util.*;
@@ -554,7 +555,7 @@ public class Block extends UnlockableContent implements Senseable{
             }
         }
 
-        if(canBeBuilt() && requirements.length > 0){
+        if(requirements.length > 0){
             stats.add(Stat.buildTime, buildCost / 60, StatUnit.seconds);
             stats.add(Stat.buildCost, StatValues.items(false, requirements));
         }
@@ -566,6 +567,7 @@ public class Block extends UnlockableContent implements Senseable{
         for(var c : consumers){
             c.display(stats);
         }
+        stats.add(StatExt.canOverdrive, canOverdrive);
 
         //Note: Power stats are added by the consumers.
         if(hasLiquids) stats.add(Stat.liquidCapacity, liquidCapacity, StatUnit.liquidUnits);
diff --git a/core/src/mindustry/world/blocks/defense/ForceProjector.java b/core/src/mindustry/world/blocks/defense/ForceProjector.java
index 7aa49ecb9895ab2322d897ab8ccfba2ed825efdc..babcdfa5926d030901223175799df5e4f5d931c0 100644
--- a/core/src/mindustry/world/blocks/defense/ForceProjector.java
+++ b/core/src/mindustry/world/blocks/defense/ForceProjector.java
@@ -22,6 +22,7 @@ import mindustry.world.*;
 import mindustry.world.blocks.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -100,9 +101,11 @@ public class ForceProjector extends Block{
 
         if(consItems) stats.timePeriod = phaseUseTime;
         super.setStats();
+        stats.add(Stat.range, radius / tilesize, StatUnit.blocks);
         stats.add(Stat.shieldHealth, shieldHealth, StatUnit.none);
         stats.add(Stat.cooldownTime, (int) (shieldHealth / cooldownBrokenBase / 60f), StatUnit.seconds);
-
+        stats.add(StatExt.regenSpeed, cooldownNormal * Time.toSeconds, StatUnit.perSecond);
+        stats.add(StatExt.regenSpeedBroken, cooldownBrokenBase * Time.toSeconds, StatUnit.perSecond);
         if(consItems && itemConsumer instanceof ConsumeItems coni){
             stats.remove(Stat.booster);
             stats.add(Stat.booster, StatValues.itemBoosters("+{0} " + StatUnit.shieldHealth.localized(), stats.timePeriod, phaseShieldBoost, phaseRadiusBoost, coni.items));
diff --git a/core/src/mindustry/world/blocks/defense/MendProjector.java b/core/src/mindustry/world/blocks/defense/MendProjector.java
index 7fd31c87cc58d06f121718414adaf9ef71421c25..6af14f3df3bc00a13168be32bfa1f9857c20ee22 100644
--- a/core/src/mindustry/world/blocks/defense/MendProjector.java
+++ b/core/src/mindustry/world/blocks/defense/MendProjector.java
@@ -52,13 +52,15 @@ public class MendProjector extends Block{
         stats.timePeriod = useTime;
         super.setStats();
 
-        stats.add(Stat.repairTime, (int)(100f / healPercent * reload / 60f), StatUnit.seconds);
         stats.add(Stat.range, range / tilesize, StatUnit.blocks);
+        stats.add(StatExt.mend, healPercent, StatUnit.percent);
+        stats.add(StatExt.mendReload, reload / 60f, StatUnit.seconds);
+        stats.add(StatExt.mendSpeed, "@%/s", Strings.autoFixed(healPercent / (reload / 60f), 1));
 
         if(findConsumer(c -> c instanceof ConsumeItems) instanceof ConsumeItems cons){
             stats.remove(Stat.booster);
             stats.add(Stat.booster, StatValues.itemBoosters(
-                "{0}" + StatUnit.timesSpeed.localized(),
+                "{0}x修复量",
                 stats.timePeriod, (phaseBoost + healPercent) / healPercent, phaseRangeBoost,
                 cons.items)
             );
diff --git a/core/src/mindustry/world/blocks/defense/RegenProjector.java b/core/src/mindustry/world/blocks/defense/RegenProjector.java
index 5d05295de8fece3979ee5ea4e9c8854bddcccb63..6490f45e0b78c8f5e23f32c976af1d2a1599c299 100644
--- a/core/src/mindustry/world/blocks/defense/RegenProjector.java
+++ b/core/src/mindustry/world/blocks/defense/RegenProjector.java
@@ -14,6 +14,7 @@ import mindustry.world.*;
 import mindustry.world.consumers.*;
 import mindustry.world.draw.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -89,13 +90,13 @@ public class RegenProjector extends Block{
         stats.timePeriod = optionalUseTime;
         super.setStats();
 
-        stats.add(Stat.repairTime, (int)(1f / (healPercent / 100f) / 60f), StatUnit.seconds);
         stats.add(Stat.range, range, StatUnit.blocks);
+        stats.add(StatExt.mendSpeed, "@%/s", Strings.autoFixed(healPercent * 60f, 1));
 
         if(findConsumer(c -> c instanceof ConsumeItems) instanceof ConsumeItems cons){
             stats.remove(Stat.booster);
             stats.add(Stat.booster, StatValues.itemBoosters(
-                "{0}" + StatUnit.timesSpeed.localized(),
+                "{0}x修复速度",
                 stats.timePeriod, optionalMultiplier, 0f,
                 cons.items)
             );
diff --git a/core/src/mindustry/world/blocks/defense/ShieldWall.java b/core/src/mindustry/world/blocks/defense/ShieldWall.java
index 8f7a1135a1c2b46b7b83b8ca58cdbb12ccc90784..53c0889446bda2891a6417c435ff255953447b92 100644
--- a/core/src/mindustry/world/blocks/defense/ShieldWall.java
+++ b/core/src/mindustry/world/blocks/defense/ShieldWall.java
@@ -8,6 +8,7 @@ import arc.util.io.*;
 import mindustry.annotations.Annotations.*;
 import mindustry.graphics.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -32,6 +33,9 @@ public class ShieldWall extends Wall{
         super.setStats();
 
         stats.add(Stat.shieldHealth, shieldHealth);
+        stats.add(Stat.cooldownTime, breakCooldown / Time.toSeconds, StatUnit.seconds);
+        stats.add(StatExt.regenSpeed, regenSpeed * Time.toSeconds, StatUnit.perSecond);
+
     }
 
     public class ShieldWallBuild extends WallBuild{
diff --git a/core/src/mindustry/world/blocks/defense/turrets/PointDefenseTurret.java b/core/src/mindustry/world/blocks/defense/turrets/PointDefenseTurret.java
index 97aedf43b5595bcfb63ea9ecce91dc6e57967e92..cd30d93b35b0547658c39c0b0f6e5ef0f8300973 100644
--- a/core/src/mindustry/world/blocks/defense/turrets/PointDefenseTurret.java
+++ b/core/src/mindustry/world/blocks/defense/turrets/PointDefenseTurret.java
@@ -52,6 +52,7 @@ public class PointDefenseTurret extends ReloadTurret{
         super.setStats();
 
         stats.add(Stat.reload, 60f / reload, StatUnit.perSecond);
+        stats.add(Stat.damage, bulletDamage);
     }
 
     public class PointDefenseBuild extends ReloadTurretBuild{
diff --git a/core/src/mindustry/world/blocks/distribution/BufferedItemBridge.java b/core/src/mindustry/world/blocks/distribution/BufferedItemBridge.java
index 8a6de353e073b653abfd14a2610905705cc4e034..3a206039844a00ea43e9ac3c12e238868392b426 100644
--- a/core/src/mindustry/world/blocks/distribution/BufferedItemBridge.java
+++ b/core/src/mindustry/world/blocks/distribution/BufferedItemBridge.java
@@ -9,6 +9,7 @@ import mindustry.gen.*;
 import mindustry.graphics.*;
 import mindustry.type.*;
 import mindustry.world.*;
+import mindustry.world.meta.*;
 import mindustryX.features.*;
 
 import static mindustry.Vars.*;
@@ -26,6 +27,14 @@ public class BufferedItemBridge extends ItemBridge{
         canOverdrive = true;
     }
 
+    @Override
+    public void setStats(){
+        super.setStats();
+
+        stats.add(StatExt.bufferCapacity, bufferCapacity);
+        stats.add(Stat.itemsMoved, Strings.autoFixed(bufferCapacity * 60f / speed ,2) , StatUnit.itemsSecond);
+    }
+
     public class BufferedItemBridgeBuild extends ItemBridgeBuild{
         ItemBuffer buffer = new ItemBuffer(bufferCapacity);
 
diff --git a/core/src/mindustry/world/blocks/distribution/Junction.java b/core/src/mindustry/world/blocks/distribution/Junction.java
index 7c1ac4c85932b974434abce3cbd3a160edcdf0ab..4396a58080056488344ae0d8c86d2b0c660283b3 100644
--- a/core/src/mindustry/world/blocks/distribution/Junction.java
+++ b/core/src/mindustry/world/blocks/distribution/Junction.java
@@ -30,6 +30,16 @@ public class Junction extends Block{
         noUpdateDisabled = true;
     }
 
+    @Override
+    public void setStats(){
+        super.setStats();
+
+        //have to add a custom calculated speed, since the actual movement speed is apparently not linear
+        stats.add(Stat.itemCapacity, capacity);
+        stats.add(Stat.itemsMoved,Strings.autoFixed(60f / speed * capacity ,2) , StatUnit.itemsSecond);
+    }
+
+
     @Override
     public boolean outputsItems(){
         return true;
diff --git a/core/src/mindustry/world/blocks/power/ImpactReactor.java b/core/src/mindustry/world/blocks/power/ImpactReactor.java
index 136cf66b46876bb32783bab353f1da20726410d8..528b2960a70af587b6b6fbbaf203646d0bd6a594 100644
--- a/core/src/mindustry/world/blocks/power/ImpactReactor.java
+++ b/core/src/mindustry/world/blocks/power/ImpactReactor.java
@@ -13,6 +13,7 @@ import mindustry.logic.*;
 import mindustry.ui.*;
 import mindustry.world.draw.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 public class ImpactReactor extends PowerGenerator{
     public final int timerUse = timers++;
@@ -41,6 +42,14 @@ public class ImpactReactor extends PowerGenerator{
         explodeSound = Sounds.explosionbig;
     }
 
+    private float warmupToTime(float warmup, float timeScale) {
+        return Mathf.log(1f - warmupSpeed * timeScale, 1f - warmup);
+    }
+
+    private float timeToWarmup(float time, float timeScale) {
+        return 1f - Mathf.pow(1 - warmupSpeed * timeScale, time);
+    }
+
     @Override
     public void setBars(){
         super.setBars();
@@ -59,6 +68,14 @@ public class ImpactReactor extends PowerGenerator{
         if(hasItems){
             stats.add(Stat.productionTime, itemDuration / 60f, StatUnit.seconds);
         }
+        float startTime = warmupToTime(Mathf.pow(consPower.usage / powerProduction, 1f / 5f), 1f);
+        stats.add(StatExt.warmupPartial, startTime / 60f, StatUnit.seconds);
+        stats.add(StatExt.warmupTime, warmupToTime(0.999f, 1f) / 60f, StatUnit.seconds);
+        float startConsPower = 0;
+        for (int tick = 1;tick < startTime;tick++) {
+            startConsPower += consPower.usage - Mathf.pow(timeToWarmup(tick, 1f), 5f) * powerProduction;
+        }
+        stats.add(StatExt.warmupPower, Mathf.ceil(startConsPower / 50f) * 50f, StatUnit.none);
     }
 
     public class ImpactReactorBuild extends GeneratorBuild{
diff --git a/core/src/mindustry/world/blocks/sandbox/PowerSource.java b/core/src/mindustry/world/blocks/sandbox/PowerSource.java
index 0e011c9bac5573a8124e5e603f0054319eaff0ba..fa8abf6f6424f11e2155a1258157416f1e54423a 100644
--- a/core/src/mindustry/world/blocks/sandbox/PowerSource.java
+++ b/core/src/mindustry/world/blocks/sandbox/PowerSource.java
@@ -16,6 +16,12 @@ public class PowerSource extends PowerNode{
         envEnabled = Env.any;
     }
 
+    @Override
+    public void setStats() {
+        super.setStats();
+        stats.add(Stat.basePowerGeneration, powerProduction * 60f, StatUnit.powerSecond);
+    }
+
     public class PowerSourceBuild extends PowerNodeBuild{
         @Override
         public void onProximityUpdate(){
diff --git a/core/src/mindustry/world/blocks/sandbox/PowerVoid.java b/core/src/mindustry/world/blocks/sandbox/PowerVoid.java
index d0a8acf4d7438f25f5a9ec275982f6564f4a4483..6943d06cf9438d757ccc61e582fac169c20683d9 100644
--- a/core/src/mindustry/world/blocks/sandbox/PowerVoid.java
+++ b/core/src/mindustry/world/blocks/sandbox/PowerVoid.java
@@ -15,6 +15,5 @@ public class PowerVoid extends PowerBlock{
     @Override
     public void setStats(){
         super.setStats();
-        stats.remove(Stat.powerUse);
     }
 }
diff --git a/core/src/mindustry/world/consumers/ConsumeItemDynamic.java b/core/src/mindustry/world/consumers/ConsumeItemDynamic.java
index b026ce3df9bf727ee389d951697f55e8ab107e25..18a1275dee82959a029866c6013346e3e2f976ed 100644
--- a/core/src/mindustry/world/consumers/ConsumeItemDynamic.java
+++ b/core/src/mindustry/world/consumers/ConsumeItemDynamic.java
@@ -43,7 +43,7 @@ public class ConsumeItemDynamic extends Consume{
         int i = 0;
 
         for(ItemStack stack : items.get(build)){
-            table.add(new ReqImage(StatValues.stack(stack.item, Math.round(stack.amount * multiplier.get(build))),
+            table.add(new ReqImage(StatValues.stack(stack.item, Math.round(stack.amount * multiplier.get(build)), () -> build.items.get(stack.item)),
             () -> build.items != null && build.items.has(stack.item, Math.round(stack.amount * multiplier.get(build))))).padRight(8).left();
             if(++i % 4 == 0) table.row();
         }
diff --git a/core/src/mindustry/world/consumers/ConsumeItems.java b/core/src/mindustry/world/consumers/ConsumeItems.java
index c43fa42a320a88864ca8d73b88504a8c31fa1739..92d2d1465df74bf84f3a5d39e38c4dbb2795c112 100644
--- a/core/src/mindustry/world/consumers/ConsumeItems.java
+++ b/core/src/mindustry/world/consumers/ConsumeItems.java
@@ -33,7 +33,7 @@ public class ConsumeItems extends Consume{
         table.table(c -> {
             int i = 0;
             for(var stack : items){
-                c.add(new ReqImage(StatValues.stack(stack.item, Math.round(stack.amount * multiplier.get(build))),
+                c.add(new ReqImage(StatValues.stack(stack.item, Math.round(stack.amount * multiplier.get(build)), () -> build.items.get(stack.item)),
                 () -> build.items.has(stack.item, Math.round(stack.amount * multiplier.get(build))))).padRight(8);
                 if(++i % 4 == 0) c.row();
             }
diff --git a/core/src/mindustry/world/consumers/ConsumePayloadDynamic.java b/core/src/mindustry/world/consumers/ConsumePayloadDynamic.java
index ebb6f324301c123e852285150b9467f59f35d414..e038f3ee493377f161843a6a469e75f82c7806b8 100644
--- a/core/src/mindustry/world/consumers/ConsumePayloadDynamic.java
+++ b/core/src/mindustry/world/consumers/ConsumePayloadDynamic.java
@@ -63,7 +63,7 @@ public class ConsumePayloadDynamic extends Consume{
         table.table(c -> {
             int i = 0;
             for(var stack : pay){
-                c.add(new ReqImage(StatValues.stack(stack.item, Math.round(stack.amount * multiplier.get(build))),
+                c.add(new ReqImage(StatValues.stack(stack.item, Math.round(stack.amount * multiplier.get(build)), () -> build.getPayloads().get(stack.item)),
                 () -> inv.contains(stack.item, Math.round(stack.amount * multiplier.get(build))))).padRight(8);
                 if(++i % 4 == 0) c.row();
             }
diff --git a/core/src/mindustry/world/meta/Stat.java b/core/src/mindustry/world/meta/Stat.java
index b1257d6232977ca6baaa841b0483fe3d3d1f5871..4249bb2ca961dfbc20fa38fe5b1cc8f079bbc554 100644
--- a/core/src/mindustry/world/meta/Stat.java
+++ b/core/src/mindustry/world/meta/Stat.java
@@ -25,17 +25,18 @@ public class Stat implements Comparable<Stat>{
     heatCapacity = new Stat("heatCapacity"),
     viscosity = new Stat("viscosity"),
     temperature = new Stat("temperature"),
-    flying = new Stat("flying"),
-    speed = new Stat("speed"),
-    buildSpeed = new Stat("buildSpeed"),
-    mineSpeed = new Stat("mineSpeed"),
-    mineTier = new Stat("mineTier"),
-    payloadCapacity = new Stat("payloadCapacity"),
+    flying = new Stat("flying", StatCat.movement),
+    speed = new Stat("speed", StatCat.movement),
+    buildSpeed = new Stat("buildSpeed", StatCat.support),
+    mineSpeed = new Stat("mineSpeed", StatCat.support),
+    mineTier = new Stat("mineTier", StatCat.support),
+    payloadCapacity = new Stat("payloadCapacity", StatCat.support),
+
     baseDeflectChance = new Stat("baseDeflectChance"),
     lightningChance = new Stat("lightningChance"),
     lightningDamage = new Stat("lightningDamage"),
-    abilities = new Stat("abilities"),
-    canBoost = new Stat("canBoost"),
+    abilities = new Stat("abilities", StatCat.combat),
+    canBoost = new Stat("canBoost", StatCat.movement),
     maxUnits = new Stat("maxUnits"),
 
     damageMultiplier = new Stat("damageMultiplier"),
@@ -71,8 +72,8 @@ public class Stat implements Comparable<Stat>{
     linkRange = new Stat("linkRange", StatCat.crafting),
     instructions = new Stat("instructions", StatCat.crafting),
 
-    weapons = new Stat("weapons", StatCat.function),
-    bullet = new Stat("bullet", StatCat.function),
+    weapons = new Stat("weapons", StatCat.combat),
+    bullet = new Stat("bullet", StatCat.combat),
 
     speedIncrease = new Stat("speedIncrease", StatCat.function),
     repairTime = new Stat("repairTime", StatCat.function),
diff --git a/core/src/mindustry/world/meta/StatCat.java b/core/src/mindustry/world/meta/StatCat.java
index 416df5a20af4767cdfdc2646bce19468ad11cd28..239311eea91980f2c3e0facd6613b2373cc11909 100644
--- a/core/src/mindustry/world/meta/StatCat.java
+++ b/core/src/mindustry/world/meta/StatCat.java
@@ -15,7 +15,10 @@ public class StatCat implements Comparable<StatCat>{
     items = new StatCat("items"),
     crafting = new StatCat("crafting"),
     function = new StatCat("function"),
-    optional = new StatCat("optional");
+    optional = new StatCat("optional"),
+    support =  new StatCat("support"),
+    combat =  new StatCat("combat"),
+    movement =  new StatCat("movement");
 
     public final String name;
     public final int id;
diff --git a/core/src/mindustry/world/meta/StatValues.java b/core/src/mindustry/world/meta/StatValues.java
index 8b2c98db0d05f232d2be848fcb716f738c1bcfa3..6dd52bb27fc05c1ddb0ebcf30bd5d709fb898d9f 100644
--- a/core/src/mindustry/world/meta/StatValues.java
+++ b/core/src/mindustry/world/meta/StatValues.java
@@ -25,6 +25,8 @@ import mindustry.ui.*;
 import mindustry.world.*;
 import mindustry.world.blocks.defense.turrets.*;
 import mindustry.world.blocks.environment.*;
+import mindustryX.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -259,6 +261,17 @@ public class StatValues{
         return stack(item.uiIcon, amount, item);
     }
 
+    @MindustryXApi
+    public static Stack stack(UnlockableContent item, int amount, Intp curAmount){
+        Stack stack = stack(item.uiIcon, amount, item);
+        stack.add(new Table(t -> {
+            t.left().top();
+            t.label(() -> String.valueOf(curAmount.get())).get().setFontScale(0.6f);
+            t.pack();
+        }));
+        return stack;
+    }
+
     public static Stack stack(UnlockableContent item, int amount, boolean tooltip){
         return stack(item.uiIcon, amount, item, tooltip);
     }
@@ -331,7 +344,7 @@ public class StatValues{
 
                 if(state.isGame()){
                     var blocks = Vars.content.blocks()
-                    .select(block -> (!checkFloors || block instanceof Floor) && indexer.isBlockPresent(block) && block.attributes.get(attr) != 0 && !((block instanceof Floor f && f.isDeep()) && !floating))
+                    .select(block -> (!checkFloors || block instanceof Floor) && block.attributes.get(attr) != 0 && !((block instanceof Floor f && f.isDeep()) && !floating))
                     .with(s -> s.sort(f -> f.attributes.get(attr)));
 
                     if(blocks.any()){
@@ -567,29 +580,60 @@ public class StatValues{
         };
     }
 
+    @MindustryXApi.Keep
     public static StatValue abilities(Seq<Ability> abilities){
+        return abilities(null, abilities);
+    }
+
+    @MindustryXApi
+    public static StatValue abilities(@Nullable UnitType unit, Seq<Ability> abilities){
         return table -> {
             table.row();
             table.table(t -> {
-                int count = 0;
+
                 for(Ability ability : abilities){
                     if(ability.display){
                         t.table(Styles.grayPanel, a -> {
-                            a.add("[accent]" + ability.localized()).padBottom(4).center().top().expandX();
-                            a.row();
                             a.left().top().defaults().left();
+                            a.add("[accent]" + ability.localized()).minWidth(100).padBottom(4);
+                            var customDescription = unit == null ? null : StatExt.description(ability, unit);
+                            if(customDescription != null){
+                                a.add(customDescription).row();
+                            }
+                            a.defaults().colspan(2);
                             ability.addStats(a);
-                        }).pad(5).margin(10).growX().top().uniformX();
-                        if((++count) == 2){
-                            count = 0;
-                            t.row();
-                        }
+                        }).pad(5).margin(10).growX().top();
+                        t.row();
                     }
-                };
+                }
             });
         };
     }
 
+    public static StatValue targets(BlockFlag[] targetFlags){
+        return table -> {
+            table.row();
+            table.table(t -> {
+                t.background(Styles.grayPanel);
+                for(BlockFlag flag : targetFlags){
+                    if(flag == null) continue;
+                    t.add(flag.name()).width(150f).padBottom(5f);
+                    int count = 0;
+                    for(Block block : content.blocks()){
+                        if(block.flags.contains(flag)){
+                            if(count >= 3){
+                                t.add("\uE813").width(30f);
+                                break;
+                            }else t.add(block.emoji()).width(30f);
+                            count += 1;
+                        }
+                    }
+                    t.row();
+                }
+            }).padLeft(12f);
+        };
+    }
+
     public static <T extends UnlockableContent> StatValue ammo(ObjectMap<T, BulletType> map){
         return ammo(map, false, false);
     }
@@ -627,7 +671,9 @@ public class StatValues{
                         bt.row();
                     }
 
-                    if(type.damage > 0 && (type.collides || type.splashDamage <= 0)){
+                    if(type instanceof LightningBulletType lb){
+                        lightning(0, lb.damage, lb.lightningLength, lb.lightningLengthRand).display(bt);
+                    }else if(type.damage > 0 && (type.collides || type.splashDamage <= 0)){
                         if(type.continuousDamage() > 0){
                             bt.add(Core.bundle.format("bullet.damage", type.continuousDamage()) + StatUnit.perSecond.localized());
                         }else{
@@ -636,11 +682,11 @@ public class StatValues{
                     }
 
                     if(type.buildingDamageMultiplier != 1){
-                        sep(bt, Core.bundle.format("bullet.buildingdamage", ammoStat((int)(type.buildingDamageMultiplier * 100 - 100))));
+                        sep(bt, multStat(type.buildingDamageMultiplier) + "[lightgray]x建筑伤害");
                     }
 
                     if(type.rangeChange != 0 && !compact){
-                        sep(bt, Core.bundle.format("bullet.range", ammoStat(type.rangeChange / tilesize)));
+                        sep(bt, "[lightgray]射程 " + ammoStat(type.rangeChange / tilesize) + " [lightgray]格");
                     }
 
                     if(type.shieldDamageMultiplier != 1){
@@ -656,8 +702,7 @@ public class StatValues{
                     }
 
                     if(!compact && !Mathf.equal(type.reloadMultiplier, 1f)){
-                        int val = (int)(type.reloadMultiplier * 100 - 100);
-                        sep(bt, Core.bundle.format("bullet.reload", ammoStat(val)));
+                        sep(bt, multStat(type.reloadMultiplier) + "[lightgray]x射速");
                     }
 
                     if(type.knockback > 0){
@@ -672,8 +717,24 @@ public class StatValues{
                         sep(bt, Core.bundle.format("bullet.healamount", Strings.autoFixed(type.healAmount, 2)));
                     }
 
-                    if(type.pierce || type.pierceCap != -1){
-                        sep(bt, type.pierceCap == -1 ? "@bullet.infinitepierce" : Core.bundle.format("bullet.pierce", type.pierceCap));
+                    if((type.pierce || type.pierceCap != -1) && !(type instanceof PointLaserBulletType)){
+                        boolean laserPierce = type instanceof LaserBulletType || type instanceof ContinuousLaserBulletType || type instanceof ShrapnelBulletType;
+                        boolean pierceBuilding = laserPierce || type instanceof ContinuousFlameBulletType || type instanceof RailBulletType || type.pierceBuilding;
+                        boolean pierceUnit = type.pierce;
+                        StringBuilder str = new StringBuilder("[stat]");
+                        if(type instanceof RailBulletType rail){
+                            str.append(Strings.autoFixed(rail.pierceDamageFactor * 100f, 1) + "%衰减");
+                        }else{
+                            str.append(type.pierceCap == -1 ? "无限" : type.pierceCap + "x");
+                        }
+                        str.append("穿透[lightgray]");
+                        if(pierceBuilding && pierceUnit){
+                            str.append("建筑与单位");
+                        }else{
+                            str.append(pierceBuilding ? "建筑" : "单位");
+                        }
+                        if(laserPierce) str.append("[stat](电性)");
+                        sep(bt, str.toString());
                     }
 
                     if(type.incendAmount > 0){
@@ -681,11 +742,11 @@ public class StatValues{
                     }
 
                     if(type.homingPower > 0.01f){
-                        sep(bt, "@bullet.homing");
+                        sep(bt, "[stat]追踪[lightgray]~[]" + Strings.autoFixed(type.homingPower * 50 * Time.toSeconds, 1) + "°/s[lightgray]~[]" + Strings.fixed(type.homingRange / tilesize, 1) + "[lightgray]格");
                     }
 
-                    if(type.lightning > 0){
-                        sep(bt, Core.bundle.format("bullet.lightning", type.lightning, type.lightningDamage < 0 ? type.damage : type.lightningDamage));
+                    if(!(type instanceof LightningBulletType) && type.lightning > 0){
+                        lightning(type.lightning, type.lightningDamage < 0 ? type.damage : type.lightningDamage, type.lightningLength, type.lightningLengthRand).display(bt);
                     }
 
                     if(type.pierceArmor){
@@ -714,39 +775,51 @@ public class StatValues{
                     }
 
                     if(type.intervalBullet != null){
-                        bt.row();
-
-                        Table ic = new Table();
-                        ammo(ObjectMap.of(t, type.intervalBullet), true, false).display(ic);
-                        Collapser coll = new Collapser(ic, true);
-                        coll.setDuration(0.1f);
-
-                        bt.table(it -> {
-                            it.left().defaults().left();
+                        collapse(bt,Core.bundle.format("bullet.interval", Strings.autoFixed(type.intervalBullets / type.bulletInterval * 60, 2)),ic->{
+                            ammo(ObjectMap.of(t, type.intervalBullet), true, false).display(ic);
+                        });
+                    }
 
-                            it.add(Core.bundle.format("bullet.interval", Strings.autoFixed(type.intervalBullets / type.bulletInterval * 60, 2)));
-                            it.button(Icon.downOpen, Styles.emptyi, () -> coll.toggle(false)).update(i -> i.getStyle().imageUp = (!coll.isCollapsed() ? Icon.upOpen : Icon.downOpen)).size(8).padLeft(16f).expandX();
+                    if(type instanceof EmpBulletType eb){
+                        collapse(bt, Strings.format("[stat]EMP~@[lightgray]格[]~[white]\uE810[]@%/[white]\uE86D[]@%~[white]\uF899[][green]@%[]/[negstat]@%[]",
+                        Strings.autoFixed(eb.radius / tilesize, 0),
+                        Strings.autoFixed(eb.powerDamageScl * 100, 0),
+                        Strings.autoFixed(eb.unitDamageScl * 100, 0),
+                        Strings.autoFixed(eb.timeIncrease * 100, 0),
+                        Strings.autoFixed(eb.powerSclDecrease * 100, 0)
+                        ), ec -> {
+                            ec.defaults().padLeft(5f);
+                            sep(ec, Strings.format("[stat]对敌方电网建筑造成@%子弹伤害", Strings.autoFixed(eb.powerDamageScl * 100, 0)));
+                            sep(ec, Strings.format("[stat]对敌方单位造成@%子弹伤害", Strings.autoFixed(eb.unitDamageScl * 100, 0)));
+                            sep(ec, Strings.format("[stat]对我方耗电建筑超速至@%", Strings.autoFixed(eb.timeIncrease * 100, 0)));
+                            sep(ec, Strings.format("[stat]对敌方电网建筑减速至@%", Strings.autoFixed(eb.powerSclDecrease * 100, 0)));
                         });
-                        bt.row();
-                        bt.add(coll);
                     }
 
                     if(type.fragBullet != null){
-                        bt.row();
-
-                        Table fc = new Table();
-                        ammo(ObjectMap.of(t, type.fragBullet), true, false).display(fc);
-                        Collapser coll = new Collapser(fc, true);
-                        coll.setDuration(0.1f);
-
-                        bt.table(ft -> {
-                            ft.left().defaults().left();
+                        collapse(bt, Core.bundle.format("bullet.frags", type.fragBullets), fc -> {
+                            ammo(ObjectMap.of(t, type.fragBullet), true, false).display(fc);
+                        });
+                    }
 
-                            ft.add(Core.bundle.format("bullet.frags", type.fragBullets));
-                            ft.button(Icon.downOpen, Styles.emptyi, () -> coll.toggle(false)).update(i -> i.getStyle().imageUp = (!coll.isCollapsed() ? Icon.upOpen : Icon.downOpen)).size(8).padLeft(16f).expandX();
+                    Seq<BulletType> spawn = type.spawnBullets.copy();
+                    if(spawn.any()){
+                        collapse(bt, Strings.format("[stat]@x[lightgray]生成子弹：", spawn.size), sc -> {
+                            while(spawn.any()){
+                                BulletType bullet = spawn.first();
+                                Boolf<BulletType> pred = b -> bullet.damage == b.damage && bullet.splashDamage == b.splashDamage;
+                                //通过pred的的子弹被认为和当前子弹是一样的，合并显示
+                                int count = spawn.count(pred);
+                                if(count == type.spawnBullets.size){
+                                    ammo(ObjectMap.of(t, bullet), true, false).display(sc);
+                                }else{
+                                    sep(sc, Strings.format(" [stat]@x[lightgray]子弹：", count)).padLeft(0f);//不知道为什么padLeft0刚刚好，就这样了
+                                    ammo(ObjectMap.of(t, bullet), true, false).display(sc);
+                                }
+                                bt.row();
+                                spawn.removeAll(pred);
+                            }
                         });
-                        bt.row();
-                        bt.add(coll);
                     }
                 }).padLeft(5).padTop(5).padBottom(compact ? 0 : 5).growX().margin(compact ? 0 : 10);
                 table.row();
@@ -754,12 +827,48 @@ public class StatValues{
         };
     }
 
+    public static StatValue lightning(int shots, float damage, int length, int lengthRand){
+        return table -> {
+            String str = "[lightgray]";
+            if(shots > 0){
+                str += String.format("[stat]%d[]x", shots);
+            }
+            str += String.format("闪电~[stat]%s[]伤害~", Strings.autoFixed(damage, 1));
+            if(lengthRand > 0){
+                str += String.format("[stat]%d~%d[]长度", length, length + lengthRand);
+            }else{
+                str += String.format("[stat]%d[]长度", length);
+            }
+            sep(table, str);
+        };
+    }
+
     //for AmmoListValue
     private static Cell<?> sep(Table table, String text){
         table.row();
         return table.add(text);
     }
 
+    private static void collapse(Table table, String text, Cons<Table> cons){
+        table.row();
+
+        Table collt = new Table();
+        collt.left().defaults().left();
+        cons.get(collt);
+
+        Collapser coll = new Collapser(collt, true);
+        coll.setDuration(0.1f);
+
+        table.table(tt -> {
+            tt.add(text);
+            tt.button(Icon.downOpen, Styles.emptyi, () -> coll.toggle(false))
+            .update(i -> i.getStyle().imageUp = (!coll.isCollapsed() ? Icon.upOpen : Icon.downOpen))
+            .size(8).padLeft(16f).expandX();
+        });
+        table.row();
+        table.add(coll);
+    }
+
     //for AmmoListValue
     private static String ammoStat(float val){
         return (val > 0 ? "[stat]+" : "[negstat]") + Strings.autoFixed(val, 1);
